<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!--
Copyright (c) 2021 STMicroelectronics.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device schemaVersion="1.1"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>STM32C031</name>
  <version>0.2</version>    
  <description>STM32C031</description>  
  <cpu>
    <name>CM0</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits> 
  <width>32</width>
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
        <name>ADC</name>
        <description>Analog to Digital Converter</description>
		<groupName>ADC</groupName>
        <baseAddress>0x40012400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>ADC</name>
          <description>ADC interrupt</description>
          <value>12</value>
        </interrupt>
        <registers>
          <register>
            <name>ADC_ISR</name>
            <displayName>ADC_ISR</displayName>
            <description>ADC interrupt and status register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADRDY</name>
                <description>ADC ready
This bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.
It is cleared by software writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC is ready to start conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSMP</name>
                <description>End of sampling flag
This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to ‘1’.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of sampling phase reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOC</name>
                <description>End of conversion flag
This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Channel conversion not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Channel conversion complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOS</name>
                <description>End of sequence flag
This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Conversion sequence not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Conversion sequence complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVR</name>
                <description>ADC overrun
This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1</name>
                <description>Analog watchdog 1 flag
This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2</name>
                <description>Analog watchdog 2 flag
This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3</name>
                <description>Analog watchdog 3 flag
This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOCAL</name>
                <description>End Of Calibration flag
This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calibration is not complete</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calibration is complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCRDY</name>
                <description>Channel Configuration Ready flag
This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.
Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Channel configuration update not applied. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Channel configuration update is applied.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_IER</name>
            <displayName>ADC_IER</displayName>
            <description>ADC interrupt enable register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADRDYIE</name>
                <description>ADC ready interrupt enable
This bit is set and cleared by software to enable/disable the ADC Ready interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADRDY interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSMPIE</name>
                <description>End of sampling flag interrupt enable
This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOSMP interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOCIE</name>
                <description>End of conversion interrupt enable
This bit is set and cleared by software to enable/disable the end of conversion interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOC interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOC interrupt enabled. An interrupt is generated when the EOC bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSIE</name>
                <description>End of conversion sequence interrupt enable
This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOS interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOS interrupt enabled. An interrupt is generated when the EOS bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRIE</name>
                <description>Overrun interrupt enable
This bit is set and cleared by software to enable/disable the overrun interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Overrun interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1IE</name>
                <description>Analog watchdog 1 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog interrupt.
Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2IE</name>
                <description>Analog watchdog 2 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog interrupt.
Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3IE</name>
                <description>Analog watchdog 3 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog interrupt.
Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOCALIE</name>
                <description>End of calibration interrupt enable
This bit is set and cleared by software to enable/disable the end of calibration interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>End of calibration interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of calibration interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCRDYIE</name>
                <description>Channel Configuration Ready Interrupt enable
This bit is set and cleared by software to enable/disable the channel configuration ready interrupt.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Channel configuration ready interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Channel configuration ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CR</name>
            <displayName>ADC_CR</displayName>
            <description>ADC control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADEN</name>
                <description>ADC enable command
This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.
It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.
Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, ADSTP = 0, ADSTART = 0, ADDIS = 0 and ADEN = 0)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC is disabled (OFF state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to enable the ADC.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDIS</name>
                <description>ADC disable command
This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).
It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).
Note: Setting ADDIS to ‘1’ is only effective when ADEN = 1 and ADSTART = 0 (which ensures that no conversion is ongoing)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADDIS command ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADSTART</name>
                <description>ADC start conversion command
This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).
It is cleared by hardware:
In single conversion mode (CONT = 0, DISCEN = 0), when software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion Sequence (EOS) flag.
In discontinuous conversion mode(CONT = 0, DISCEN = 1), when the software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion (EOC) flag.
In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.
Note: The software is allowed to set ADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC).
After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC conversion is ongoing.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to start the ADC. Read 1 means that the ADC is operating and may be converting.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADSTP</name>
                <description>ADC stop conversion command
This bit is set by software to stop and discard an ongoing conversion (ADSTP Command).
It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.
Note: Setting ADSTP to ‘1’ is only effective when ADSTART = 1 and ADDIS = 0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC stop conversion command ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to stop the ADC. Read 1 means that an ADSTP command is in progress.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADVREGEN</name>
                <description>ADC Voltage Regulator Enable
This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP.
It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.
Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC voltage regulator disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC voltage regulator enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCAL</name>
                <description>ADC calibration
This bit is set by software to start the calibration of the ADC.
It is cleared by hardware after calibration is complete.
Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).
The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN = 1 and ADSTART = 0 (ADC enabled and no conversion is ongoing).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calibration complete</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to calibrate the ADC. Read at 1 means that a calibration is in progress.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CFGR1</name>
            <displayName>ADC_CFGR1</displayName>
            <description>ADC configuration register 1 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAEN</name>
                <description>Direct memory access enable
This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to .
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMACFG</name>
                <description>Direct memory access configuration
This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.
For more details, refer to page 355
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA one shot mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA circular mode selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCANDIR</name>
                <description>Scan sequence direction
This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Upward scan (from CHSEL0 to CHSEL22)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Backward scan (from CHSEL22 to CHSEL0)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RES</name>
                <description>Data resolution
These bits are written by software to select the resolution of the conversion.
Note: The software is allowed to write these bits only when ADEN = 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>12 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>10 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>6 bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALIGN</name>
                <description>Data alignment
This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page 353
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Right alignment</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Left alignment</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL</name>
                <description>External trigger selection
These bits select the external event used to trigger the start of conversion (refer to External triggers for details):
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TRG0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TRG1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TRG2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>TRG3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TRG4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>TRG5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>TRG6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>TRG7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTEN</name>
                <description>External trigger enable and polarity selection
These bits are set and cleared by software to select the external trigger polarity and enable the trigger.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Hardware trigger detection disabled (conversions can be started by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Hardware trigger detection on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Hardware trigger detection on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Hardware trigger detection on both the rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRMOD</name>
                <description>Overrun management mode
This bit is set and cleared by software and configure the way data overruns are managed.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC_DR register is preserved with the old data when an overrun is detected. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC_DR register is overwritten with the last conversion result when an overrun is detected.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CONT</name>
                <description>Single / continuous conversion mode
This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.
Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.
The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Single conversion mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Continuous conversion mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAIT</name>
                <description>Wait conversion mode
This bit is set and cleared by software to enable/disable wait conversion mode..
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wait conversion mode off</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wait conversion mode on</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTOFF</name>
                <description>Auto-off mode
This bit is set and cleared by software to enable/disable auto-off mode..
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Auto-off mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Auto-off mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISCEN</name>
                <description>Discontinuous mode
This bit is set and cleared by software to enable/disable discontinuous mode.
Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.
The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Discontinuous mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Discontinuous mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSELRMOD</name>
                <description>Mode selection of the ADC_CHSELR register
This bit is set and cleared by software to control the ADC_CHSELR feature:
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Each bit of the ADC_CHSELR register enables an input </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC_CHSELR register is able to sequence up to 8 channels</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1SGL</name>
                <description>Enable the watchdog on a single channel or on all channels
This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 enabled on all channels</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 enabled on a single channel</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1EN</name>
                <description>Analog watchdog enable
This bit is set and cleared by software.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1CH</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.
.....
Others: Reserved
Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.
The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog input Channel 0 monitored by AWD</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog input Channel 1 monitored by AWD</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x16</name>
                    <description>ADC analog input Channel 22 monitored by AWD </description>
                    <value>0x16</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CFGR2</name>
            <displayName>ADC_CFGR2</displayName>
            <description>ADC configuration register 2 </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OVSE</name>
                <description>Oversampler Enable
This bit is set and cleared by software.
Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Oversampler disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Oversampler enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVSR</name>
                <description>Oversampling ratio
This bit filed defines the number of oversampling ratio.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>4x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8x</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>16x</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>32x</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>64x</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>128x</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>256x</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVSS</name>
                <description>Oversampling shift
This bit is set and cleared by software.
Others: Reserved
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No shift</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Shift 1-bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Shift 2-bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Shift 3-bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Shift 4-bits</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Shift 5-bits</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Shift 6-bits</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Shift 7-bits</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Shift 8-bits</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOVS</name>
                <description>Triggered Oversampling
This bit is set and cleared by software.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>All oversampled conversions for a channel are done consecutively after a trigger</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Each oversampled conversion for a channel needs a trigger</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LFTRIG</name>
                <description>Low frequency trigger mode enable
This bit is set and cleared by software.
Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low Frequency Trigger Mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low Frequency Trigger Mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKMODE</name>
                <description>ADC clock mode
These bits are set and cleared by software to define how the analog ADC is clocked:
In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.
Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADCCLK (Asynchronous clock mode), generated at product level (refer to RCC section)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PCLK/2 (Synchronous clock mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PCLK/4 (Synchronous clock mode)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PCLK (Synchronous clock mode). This configuration must be enabled only if PCLK has a 50% duty clock cycle (APB prescaler configured inside the RCC must be bypassed and the system clock must by 50% duty cycle)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SMPR</name>
            <displayName>ADC_SMPR</displayName>
            <description>ADC sampling time register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMP1</name>
                <description>Sampling time selection 1
These bits are written by software to select the sampling time that applies to all channels.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1.5 ADC clock cycles </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>3.5 ADC clock cycles </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>7.5 ADC clock cycles </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>12.5 ADC clock cycles </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>19.5 ADC clock cycles </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>39.5 ADC clock cycles </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>79.5 ADC clock cycles </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>160.5 ADC clock cycles </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP2</name>
                <description>Sampling time selection 2
These bits are written by software to select the sampling time that applies to all channels.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1.5 ADC clock cycles </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>3.5 ADC clock cycles </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>7.5 ADC clock cycles </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>12.5 ADC clock cycles </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>19.5 ADC clock cycles </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>39.5 ADC clock cycles </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>79.5 ADC clock cycles </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>160.5 ADC clock cycles </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL0</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL1</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL2</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL3</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL4</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL5</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL6</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL7</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL8</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL9</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL10</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL11</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL12</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL13</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL14</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL15</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL16</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL17</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL18</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL19</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL20</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL21</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPSEL22</name>
                <description>Channel-x sampling time selection
These bits are written by software to define which sampling time is used.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
Refer to  for the maximum number of channels.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD1TR</name>
            <displayName>ADC_AWD1TR</displayName>
            <description>ADC watchdog threshold register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x0FFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT1</name>
                <description>Analog watchdog 1 lower threshold
These bits are written by software to define the lower threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT1</name>
                <description>Analog watchdog 1 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD2TR</name>
            <displayName>ADC_AWD2TR</displayName>
            <description>ADC watchdog threshold register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x0FFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT2</name>
                <description>Analog watchdog 2 lower threshold
These bits are written by software to define the lower threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT2</name>
                <description>Analog watchdog 2 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CHSELR_MOD0</name>
            <displayName>ADC_CHSELR_MOD0</displayName>
            <description>ADC channel selection register [alternate] </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CHSEL0</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL1</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL2</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL3</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL4</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL5</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL6</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL7</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL8</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL9</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL10</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL11</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL12</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL13</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL14</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL15</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL16</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL17</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL18</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL19</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL20</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL21</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSEL22</name>
                <description>Channel-x selection
These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input Channel-x is not selected for conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input Channel-x is selected for conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>ADC_CHSELR_MOD1</name>
            <displayName>ADC_CHSELR_MOD1</displayName>
            <description>ADC channel selection register [alternate] </description>
            <alternateRegister>ADC_CHSELR_MOD0</alternateRegister>
			<addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SQ1</name>
                <description>1st conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ2</name>
                <description>2nd conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ3</name>
                <description>3rd conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ4</name>
                <description>4th conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ5</name>
                <description>5th conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ6</name>
                <description>6th conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ7</name>
                <description>7th conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
Refer to SQ8[3:0] for a definition of channel selection.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ8</name>
                <description>8th conversion of the sequence
These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.
When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.
...
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CH0 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CH1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>CH12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>CH13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>CH14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>No channel selected (End of sequence)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>ADC_AWD3TR</name>
            <displayName>ADC_AWD3TR</displayName>
            <description>ADC watchdog threshold register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x0FFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT3</name>
                <description>Analog watchdog 3lower threshold
These bits are written by software to define the lower threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT3</name>
                <description>Analog watchdog 3 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog.
Refer to ADC_AWDxTR) on page 359.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_DR</name>
            <displayName>ADC_DR</displayName>
            <description>ADC data register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Converted data
These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page 353.
Just after a calibration is complete, DATA[6:0] contains the calibration factor.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD2CR</name>
            <displayName>ADC_AWD2CR</displayName>
            <description>ADC Analog Watchdog 2 Configuration register </description>
            <addressOffset>0xa0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AWD2CH0</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH1</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH2</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH3</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH4</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH5</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH6</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH7</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH8</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH9</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH10</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH11</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH12</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH13</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH14</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH15</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH16</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH17</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH18</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH19</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH20</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH21</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2CH22</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).
Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD2 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD2 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD3CR</name>
            <displayName>ADC_AWD3CR</displayName>
            <description>ADC Analog Watchdog 3 Configuration register </description>
            <addressOffset>0xa4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AWD3CH0</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH1</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH2</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH3</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH4</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH5</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH6</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH7</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH8</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH9</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH10</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH11</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH12</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH13</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH14</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH15</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH16</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH17</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH18</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH19</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH20</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH21</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3CH22</name>
                <description>Analog watchdog channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).
Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog channel-x is not monitored by AWD3 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog channel-x is monitored by AWD3 </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CALFACT</name>
            <displayName>ADC_CALFACT</displayName>
            <description>ADC Calibration factor </description>
            <addressOffset>0xb4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CALFACT</name>
                <description>Calibration factor
These bits are written by hardware or by software.
Once a calibration is complete, they are updated by hardware with the calibration factors.
Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.
Just after a calibration is complete, DATA[6:0] contains the calibration factor.
Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CCR</name>
            <displayName>ADC_CCR</displayName>
            <description>ADC common configuration register </description>
            <addressOffset>0x308</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESC</name>
                <description>ADC prescaler
Set and cleared by software to select the frequency of the clock to the ADC.
Other: Reserved
Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>input ADC clock not divided</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>input ADC clock divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>input ADC clock divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>input ADC clock divided by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>input ADC clock divided by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>input ADC clock divided by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>input ADC clock divided by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>input ADC clock divided by 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>input ADC clock divided by 32</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>input ADC clock divided by 64</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>input ADC clock divided by 128</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>input ADC clock divided by 256</description>
                    <value>0xB</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VREFEN</name>
                <description>VREFINT enable
This bit is set and cleared by software to enable/disable the VREFINT.
Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VREFINT disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VREFINT enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSEN</name>
                <description>Temperature sensor enable
This bit is set and cleared by software to enable/disable the temperature sensor.
Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Temperature sensor disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Temperature sensor enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>  
    <peripheral>
        <name>CRC</name>
        <description>Cyclic redundancy check calculation unit</description>
		<groupName>CRC</groupName>
        <baseAddress>0x40023000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>CRC_DR</name>
            <displayName>CRC_DR</displayName>
            <description>CRC data register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data register bits
This register is used to write new data to the CRC calculator.
It holds the previous CRC calculation result when it is read.
If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_IDR</name>
            <displayName>CRC_IDR</displayName>
            <description>CRC independent data register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDR</name>
                <description>General-purpose 32-bit data register bits
These bits can be used as a temporary storage location for four bytes.
This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_CR</name>
            <displayName>CRC_CR</displayName>
            <description>CRC control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESET</name>
                <description>RESET bit
This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLYSIZE</name>
                <description>Polynomial size
These bits control the size of the polynomial.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>32 bit polynomial</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bit polynomial</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8 bit polynomial</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>7 bit polynomial</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_IN</name>
                <description>Reverse input data
These bits control the reversal of the bit order of the input data</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit reversal done by byte</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Bit reversal done by half-word</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Bit reversal done by word</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>Reverse output data
This bit controls the reversal of the bit order of the output data.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit-reversed output format</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_INIT</name>
            <displayName>CRC_INIT</displayName>
            <description>CRC initial value </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT</name>
                <description>Programmable initial CRC value
This register is used to write the CRC initial value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_POL</name>
            <displayName>CRC_POL</displayName>
            <description>CRC polynomial </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x04C11DB7</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POL</name>
                <description>Programmable polynomial
This register is used to write the coefficients of the polynomial to be used for CRC calculation.
If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>DBG</name>
        <description>DBG register block</description>
		<groupName>DBG</groupName>
        <baseAddress>0x40015800</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>DBG_IDCODE</name>
            <displayName>DBG_IDCODE</displayName>
            <description>DBG device ID code register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x10000453</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DEV_ID</name>
                <description>Device identifier
This bitfield indicates the device ID.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REV_ID</name>
                <description>Revision identifier
This bitfield indicates the revision of the device.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>DBG_CR</name>
            <displayName>DBG_CR</displayName>
            <description>DBG configuration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBG_STOP</name>
                <description>Debug Stop mode</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_STANDBY</name>
                <description>Debug Standby and Shutdown modes</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
          <register>
            <name>DBG_APB_FZ1</name>
            <displayName>DBG_APB_FZ1</displayName>
            <description>DBG APB freeze register 1 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBG_TIM3_STOP</name>
                <description>Clocking of TIM3 counter when the core is halted
This bit enables/disables the clock to the counter of TIM3 when the core is halted:</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_RTC_STOP</name>
                <description>Clocking of RTC counter when the core is halted
This bit enables/disables the clock to the counter of RTC when the core is halted:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_WWDG_STOP</name>
                <description>Clocking of WWDG counter when the core is halted
This bit enables/disables the clock to the counter of WWDG when the core is halted:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_IWDG_STOP</name>
                <description>Clocking of IWDG counter when the core is halted
This bit enables/disables the clock to the counter of IWDG when the core is halted:</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_I2C1_SMBUS_TIMEOUT</name>
                <description>SMBUS timeout when core is halted</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Same behavior as in normal mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The SMBUS timeout is frozen</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DBG_APB_FZ2</name>
            <displayName>DBG_APB_FZ2</displayName>
            <description>DBG APB freeze register 2 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBG_TIM1_STOP</name>
                <description>Clocking of TIM1 counter when the core is halted
This bit enables/disables the clock to the counter of TIM1 when the core is halted:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_TIM14_STOP</name>
                <description>Clocking of TIM14 counter when the core is halted
This bit enables/disables the clock to the counter of TIM14 when the core is halted:</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_TIM16_STOP</name>
                <description>Clocking of TIM16 counter when the core is halted
This bit enables/disables the clock to the counter of TIM16 when the core is halted:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_TIM17_STOP</name>
                <description>Clocking of TIM17 counter when the core is halted
This bit enables/disables the clock to the counter of TIM17 when the core is halted:</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>DMA</name>
        <description>DMA controller</description>
		<groupName>DMA</groupName>
        <baseAddress>0x40020000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>DMA1_Channel1</name>
          <description>DMA1 channel 1 interrupt</description>
          <value>9</value>
        </interrupt>
		<interrupt>
          <name>DMA1_Channel2_3</name>
          <description>DMA1 channel 2 and 3 interrupts</description>
          <value>10</value>
        </interrupt>
        <registers>
          <register>
            <name>DMA_ISR</name>
            <displayName>DMA_ISR</displayName>
            <description>DMA interrupt status register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GIF1</name>
                <description>global interrupt flag for channel 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE, HT or TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE, HT or TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIF1</name>
                <description>transfer complete (TC) flag for channel 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIF1</name>
                <description>half transfer (HT) flag for channel 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no HT event </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a HT event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIF1</name>
                <description>transfer error (TE) flag for channel 1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GIF2</name>
                <description>global interrupt flag for channel 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE, HT or TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE, HT or TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIF2</name>
                <description>transfer complete (TC) flag for channel 2</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIF2</name>
                <description>half transfer (HT) flag for channel 2</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no HT event </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a HT event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIF2</name>
                <description>transfer error (TE) flag for channel 2</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GIF3</name>
                <description>global interrupt flag for channel 3</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE, HT or TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE, HT or TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIF3</name>
                <description>transfer complete (TC) flag for channel 3</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TC event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TC event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIF3</name>
                <description>half transfer (HT) flag for channel 3</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no HT event </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a HT event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIF3</name>
                <description>transfer error (TE) flag for channel 3</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TE event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a TE event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_IFCR</name>
            <displayName>DMA_IFCR</displayName>
            <description>DMA interrupt flag clear register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CGIF1</name>
                <description>global interrupt flag clear for channel 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTCIF1</name>
                <description>transfer complete flag clear for channel 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CHTIF1</name>
                <description>half transfer flag clear for channel 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTEIF1</name>
                <description>transfer error flag clear for channel 1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CGIF2</name>
                <description>global interrupt flag clear for channel 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTCIF2</name>
                <description>transfer complete flag clear for channel 2</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CHTIF2</name>
                <description>half transfer flag clear for channel 2</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTEIF2</name>
                <description>transfer error flag clear for channel 2</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CGIF3</name>
                <description>global interrupt flag clear for channel 3</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTCIF3</name>
                <description>transfer complete flag clear for channel 3</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CHTIF3</name>
                <description>half transfer flag clear for channel 3</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTEIF3</name>
                <description>transfer error flag clear for channel 3</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CCR1</name>
            <displayName>DMA_CCR1</displayName>
            <description>DMA channel 1 configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>channel enable
When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
Note: this bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIE</name>
                <description>transfer error interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>data transfer direction
This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>read from peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>read from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CIRC</name>
                <description>circular mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINC</name>
                <description>peripheral increment mode
Defines the increment mode for each DMA transfer to the identified peripheral.
n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MINC</name>
                <description>memory increment mode
Defines the increment mode for each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PSIZE</name>
                <description>peripheral size
Defines the data size of each DMA transfer to the identified peripheral.
In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSIZE</name>
                <description>memory size
Defines the data size of each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PL</name>
                <description>priority level
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>high</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>very high</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MEM2MEM</name>
                <description>memory-to-memory mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CNDTR1</name>
            <displayName>DMA_CNDTR1</displayName>
            <description>DMA channel 1 number of data to transfer register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDT</name>
                <description>number of data to transfer (0 to 216 - 1)
This field is updated by hardware when the channel is enabled:
It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
If this field is zero, no transfer can be served whatever the channel status (enabled or not).
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CPAR1</name>
            <displayName>DMA_CPAR1</displayName>
            <description>DMA channel 1 peripheral address register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PA</name>
                <description>peripheral address
It contains the base address of the peripheral data register from/to which the data will be read/written.
When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CMAR1</name>
            <displayName>DMA_CMAR1</displayName>
            <description>DMA channel 1 memory address register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MA</name>
                <description>peripheral address
It contains the base address of the memory from/to which the data will be read/written.
When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CCR2</name>
            <displayName>DMA_CCR2</displayName>
            <description>DMA channel 2 configuration register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>channel enable
When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
Note: this bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIE</name>
                <description>transfer error interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>data transfer direction
This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>read from peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>read from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CIRC</name>
                <description>circular mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINC</name>
                <description>peripheral increment mode
Defines the increment mode for each DMA transfer to the identified peripheral.
n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MINC</name>
                <description>memory increment mode
Defines the increment mode for each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PSIZE</name>
                <description>peripheral size
Defines the data size of each DMA transfer to the identified peripheral.
In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSIZE</name>
                <description>memory size
Defines the data size of each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PL</name>
                <description>priority level
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>high</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>very high</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MEM2MEM</name>
                <description>memory-to-memory mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CNDTR2</name>
            <displayName>DMA_CNDTR2</displayName>
            <description>DMA channel 2 number of data to transfer register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDT</name>
                <description>number of data to transfer (0 to 216 - 1)
This field is updated by hardware when the channel is enabled:
It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
If this field is zero, no transfer can be served whatever the channel status (enabled or not).
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CPAR2</name>
            <displayName>DMA_CPAR2</displayName>
            <description>DMA channel 2 peripheral address register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PA</name>
                <description>peripheral address
It contains the base address of the peripheral data register from/to which the data will be read/written.
When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CMAR2</name>
            <displayName>DMA_CMAR2</displayName>
            <description>DMA channel 2 memory address register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MA</name>
                <description>peripheral address
It contains the base address of the memory from/to which the data will be read/written.
When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CCR3</name>
            <displayName>DMA_CCR3</displayName>
            <description>DMA channel 3 configuration register</description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>channel enable
When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
Note: this bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEIE</name>
                <description>transfer error interrupt enable
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>data transfer direction
This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>read from peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>read from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CIRC</name>
                <description>circular mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINC</name>
                <description>peripheral increment mode
Defines the increment mode for each DMA transfer to the identified peripheral.
n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MINC</name>
                <description>memory increment mode
Defines the increment mode for each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PSIZE</name>
                <description>peripheral size
Defines the data size of each DMA transfer to the identified peripheral.
In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSIZE</name>
                <description>memory size
Defines the data size of each DMA transfer to the identified memory.
In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8 bits</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32 bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PL</name>
                <description>priority level
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>high</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>very high</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MEM2MEM</name>
                <description>memory-to-memory mode
Note: this bit is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CNDTR3</name>
            <displayName>DMA_CNDTR3</displayName>
            <description>DMA channel 3 number of data to transfer register</description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDT</name>
                <description>number of data to transfer (0 to 216 - 1)
This field is updated by hardware when the channel is enabled:
It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
If this field is zero, no transfer can be served whatever the channel status (enabled or not).
Note: this field is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CPAR3</name>
            <displayName>DMA_CPAR3</displayName>
            <description>DMA channel 3 peripheral address register</description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PA</name>
                <description>peripheral address
It contains the base address of the peripheral data register from/to which the data will be read/written.
When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CMAR3</name>
            <displayName>DMA_CMAR3</displayName>
            <description>DMA channel 3 memory address register</description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MA</name>
                <description>peripheral address
It contains the base address of the memory from/to which the data will be read/written.
When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
Note: this register is set and cleared by software.
It must not be written when the channel is enabled (EN = 1).
It is not read-only when the channel is enabled (EN = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>DMAMUX</name>
        <description>DMAMUX register block</description>
		<groupName>DMAMUX</groupName>
        <baseAddress>0x40020800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x800</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>DMAMUX</name>
          <description>DMAMUX interrupts</description>
          <value>11</value>
        </interrupt>
        <registers>
          <register>
            <name>DMAMUX_C0CR</name>
            <displayName>DMAMUX_C0CR</displayName>
            <description>DMAMUX request line multiplexer channel 0 configuration register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAREQ_ID</name>
                <description>DMA request identification
Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOIE</name>
                <description>Synchronization overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EGE</name>
                <description>Event generation enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event generation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event generation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SE</name>
                <description>Synchronization enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Synchronization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Synchronization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPOL</name>
                <description>Synchronization polarity
Defines the edge polarity of the selected synchronization input:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no synchronization nor detection.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBREQ</name>
                <description>Number of DMA requests minus 1 to forward
Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
This field shall only be written when both SE and EGE bits are low.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_ID</name>
                <description>Synchronization identification
Selects the synchronization input (see inputs to resources).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_C1CR</name>
            <displayName>DMAMUX_C1CR</displayName>
            <description>DMAMUX request line multiplexer channel 1 configuration register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAREQ_ID</name>
                <description>DMA request identification
Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOIE</name>
                <description>Synchronization overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EGE</name>
                <description>Event generation enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event generation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event generation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SE</name>
                <description>Synchronization enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Synchronization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Synchronization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPOL</name>
                <description>Synchronization polarity
Defines the edge polarity of the selected synchronization input:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no synchronization nor detection.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBREQ</name>
                <description>Number of DMA requests minus 1 to forward
Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
This field shall only be written when both SE and EGE bits are low.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_ID</name>
                <description>Synchronization identification
Selects the synchronization input (see inputs to resources).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_C2CR</name>
            <displayName>DMAMUX_C2CR</displayName>
            <description>DMAMUX request line multiplexer channel 2 configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAREQ_ID</name>
                <description>DMA request identification
Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOIE</name>
                <description>Synchronization overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EGE</name>
                <description>Event generation enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event generation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event generation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SE</name>
                <description>Synchronization enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Synchronization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Synchronization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPOL</name>
                <description>Synchronization polarity
Defines the edge polarity of the selected synchronization input:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no synchronization nor detection.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBREQ</name>
                <description>Number of DMA requests minus 1 to forward
Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
This field shall only be written when both SE and EGE bits are low.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_ID</name>
                <description>Synchronization identification
Selects the synchronization input (see inputs to resources).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_CSR</name>
            <displayName>DMAMUX_CSR</displayName>
            <description>DMAMUX request line multiplexer interrupt channel status register	</description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOF0</name>
                <description>Synchronization overrun event flag
The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SOF1</name>
                <description>Synchronization overrun event flag
The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SOF2</name>
                <description>Synchronization overrun event flag
The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_CFR</name>
            <displayName>DMAMUX_CFR</displayName>
            <description>DMAMUX request line multiplexer interrupt clear flag register	</description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CSOF0</name>
                <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CSOF1</name>
                <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CSOF2</name>
                <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RG0CR</name>
            <displayName>DMAMUX_RG0CR</displayName>
            <description>DMAMUX request generator channel 0 configuration register</description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SIG_ID</name>
                <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIE</name>
                <description>Trigger overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt on a trigger overrun event occurrence is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt on a trigger overrun event occurrence is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GE</name>
                <description>DMA request generator channel x enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request generator channel x disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generator channel x enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPOL</name>
                <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no trigger detection nor generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GNBREQ</name>
                <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field must be written only when GE bit is disabled.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RG1CR</name>
            <displayName>DMAMUX_RG1CR</displayName>
            <description>DMAMUX request generator channel 1 configuration register</description>
            <addressOffset>0x104</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SIG_ID</name>
                <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIE</name>
                <description>Trigger overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt on a trigger overrun event occurrence is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt on a trigger overrun event occurrence is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GE</name>
                <description>DMA request generator channel x enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request generator channel x disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generator channel x enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPOL</name>
                <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no trigger detection nor generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GNBREQ</name>
                <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field must be written only when GE bit is disabled.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RG2CR</name>
            <displayName>DMAMUX_RG2CR</displayName>
            <description>DMAMUX request generator channel 2 configuration register</description>
            <addressOffset>0x108</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SIG_ID</name>
                <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIE</name>
                <description>Trigger overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt on a trigger overrun event occurrence is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt on a trigger overrun event occurrence is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GE</name>
                <description>DMA request generator channel x enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request generator channel x disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generator channel x enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPOL</name>
                <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no trigger detection nor generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GNBREQ</name>
                <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field must be written only when GE bit is disabled.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RG3CR</name>
            <displayName>DMAMUX_RG3CR</displayName>
            <description>DMAMUX request generator channel 3 configuration register</description>
            <addressOffset>0x10c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SIG_ID</name>
                <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIE</name>
                <description>Trigger overrun interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt on a trigger overrun event occurrence is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt on a trigger overrun event occurrence is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GE</name>
                <description>DMA request generator channel x enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request generator channel x disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generator channel x enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPOL</name>
                <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event, i.e. no trigger detection nor generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GNBREQ</name>
                <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field must be written only when GE bit is disabled.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RGSR</name>
            <displayName>DMAMUX_RGSR</displayName>
            <description>DMAMUX request generator interrupt status register	</description>
            <addressOffset>0x140</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OF0</name>
                <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OF1</name>
                <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OF2</name>
                <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OF3</name>
                <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMAMUX_RGCFR</name>
            <displayName>DMAMUX_RGCFR</displayName>
            <description>DMAMUX request generator interrupt clear flag register	</description>
            <addressOffset>0x144</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COF0</name>
                <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>COF1</name>
                <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>COF2</name>
                <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>COF3</name>
                <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>EXTI</name>
        <description>EXTI address block description</description>
		<groupName>EXTI</groupName>
        <baseAddress>0x40021800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>EXTI0_1</name>
          <description>EXTI line 0 and 1 interrupt</description>
          <value>5</value>
        </interrupt>
		<interrupt>
          <name>EXTI2_3</name>
          <description>EXTI line 2 and 3 interrupt</description>
          <value>6</value>
        </interrupt>
		<interrupt>
          <name>EXTI4_5</name>
          <description>EXTI line 4 and 5 interrupt</description>
          <value>7</value>
        </interrupt>
        <registers>
          <register>
            <name>EXTI_RTSR1</name>
            <displayName>EXTI_RTSR1</displayName>
            <description>EXTI rising trigger selection register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RT0</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT1</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT2</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT3</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT4</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT5</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT6</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT7</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT8</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT9</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT10</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT11</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT12</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT13</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT14</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT15</name>
                <description>Rising trigger event configuration bit of configurable line x (x = 15 to 0)
Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FTSR1</name>
            <displayName>EXTI_FTSR1</displayName>
            <description>EXTI falling trigger selection register 1 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FT0</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT1</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT2</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT3</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT4</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT5</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT6</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT7</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT8</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT9</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT10</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT11</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT12</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT13</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT14</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT15</name>
                <description>Falling trigger event configuration bit of configurable line x (x = 15 to 0).
Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_SWIER1</name>
            <displayName>EXTI_SWIER1</displayName>
            <description>EXTI software interrupt event register 1 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SWI0</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI1</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI2</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI3</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI4</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI5</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI6</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI7</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI8</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI9</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI10</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI11</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI12</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI13</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI14</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI15</name>
                <description>Software rising edge event trigger on line x (x = 15 to 0)
Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge event generated on the corresponding line, followed by an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_RPR1</name>
            <displayName>EXTI_RPR1</displayName>
            <description>EXTI rising edge pending register 1 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RPIF0</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF1</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF2</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF3</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF4</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF5</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF6</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF7</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF8</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF9</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF10</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF11</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF12</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF13</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF14</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF15</name>
                <description>Rising edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FPR1</name>
            <displayName>EXTI_FPR1</displayName>
            <description>EXTI falling edge pending register 1 </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FPIF0</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF1</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF2</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF3</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF4</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF5</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF6</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF7</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF8</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF9</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF10</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF11</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF12</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF13</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF14</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF15</name>
                <description>Falling edge event pending for configurable line x (x = 15 to 0)
Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR1</name>
            <displayName>EXTI_EXTICR1</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTIm GPIO port selection (m = 4 * (x - 1))
These bits are written by software to select the source input for EXTIm external interrupt.
Other: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[m] pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[m] pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[m] pin</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PD[m] pin</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PF[m] pin</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI2</name>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI3</name>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR2</name>
            <displayName>EXTI_EXTICR2</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTIm GPIO port selection (m = 4 * (x - 1))
These bits are written by software to select the source input for EXTIm external interrupt.
Other: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[m] pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[m] pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[m] pin</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PD[m] pin</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PF[m] pin</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI2</name>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI3</name>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR3</name>
            <displayName>EXTI_EXTICR3</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTIm GPIO port selection (m = 4 * (x - 1))
These bits are written by software to select the source input for EXTIm external interrupt.
Other: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[m] pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[m] pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[m] pin</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PD[m] pin</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PF[m] pin</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI2</name>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI3</name>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR4</name>
            <displayName>EXTI_EXTICR4</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x6c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTIm GPIO port selection (m = 4 * (x - 1))
These bits are written by software to select the source input for EXTIm external interrupt.
Other: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[m] pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[m] pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[m] pin</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PD[m] pin</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PF[m] pin</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI2</name>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTI3</name>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>EXTI_IMR1</name>
            <displayName>EXTI_IMR1</displayName>
            <description>EXTI CPU wakeup with interrupt mask register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFF80000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IM</name>
                <description>CPU wakeup with interrupt mask</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IM19</name>
                <description>IM19</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>IM23</name>
                <description>IM23</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>IM25</name>
                <description>IM25</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>IM31</name>
                <description>IM31</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>EXTI_EMR1</name>
            <displayName>EXTI_EMR1</displayName>
            <description>EXTI CPU wakeup with event mask register </description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EM</name>
                <description>CPU wakeup with event generation mask</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EM19</name>
                <description>EM19</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>EM23</name>
                <description>EM23</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>EM25</name>
                <description>EM25</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			  <field>
                <name>EM31</name>
                <description>EM31</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
        </registers>
    </peripheral>
	<peripheral>
        <name>GPIOA</name>
        <description>GPIOA address block description</description>
		<groupName>GPIO</groupName>
        <baseAddress>0x50000000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOA_MODER</name>
            <displayName>GPIOA_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xEBFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OTYPER</name>
            <displayName>GPIOA_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OSPEEDR</name>
            <displayName>GPIOA_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_PUPDR</name>
            <displayName>GPIOA_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x24000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_IDR</name>
            <displayName>GPIOA_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_ODR</name>
            <displayName>GPIOA_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BSRR</name>
            <displayName>GPIOA_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_LCKR</name>
            <displayName>GPIOA_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
LOCK key write sequence:
WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’ (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the lock.
After the first lock sequence on any bit of the port, any read access on the LCKK bit returns ‘1’ until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRL</name>
            <displayName>GPIOA_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRH</name>
            <displayName>GPIOA_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BRR</name>
            <displayName>GPIOA_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>GPIOB</name>
        <description>GPIOB address block description</description>
		<groupName>GPIO</groupName>
        <baseAddress>0x50000400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOB_MODER</name>
            <displayName>GPIOB_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xEBFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OTYPER</name>
            <displayName>GPIOB_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OSPEEDR</name>
            <displayName>GPIOB_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_PUPDR</name>
            <displayName>GPIOB_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x24000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_IDR</name>
            <displayName>GPIOB_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_ODR</name>
            <displayName>GPIOB_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BSRR</name>
            <displayName>GPIOB_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_LCKR</name>
            <displayName>GPIOB_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
LOCK key write sequence:
WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’ (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the lock.
After the first lock sequence on any bit of the port, any read access on the LCKK bit returns ‘1’ until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRL</name>
            <displayName>GPIOB_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRH</name>
            <displayName>GPIOB_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BRR</name>
            <displayName>GPIOB_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>GPIOC</name>
        <description>GPIOC address block description</description>
		<groupName>GPIO</groupName>
        <baseAddress>0x50000800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOC_MODER</name>
            <displayName>GPIOC_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xEBFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OTYPER</name>
            <displayName>GPIOC_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OSPEEDR</name>
            <displayName>GPIOC_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_PUPDR</name>
            <displayName>GPIOC_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x24000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_IDR</name>
            <displayName>GPIOC_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_ODR</name>
            <displayName>GPIOC_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BSRR</name>
            <displayName>GPIOC_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_LCKR</name>
            <displayName>GPIOC_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
LOCK key write sequence:
WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’ (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the lock.
After the first lock sequence on any bit of the port, any read access on the LCKK bit returns ‘1’ until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_AFRL</name>
            <displayName>GPIOC_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_AFRH</name>
            <displayName>GPIOC_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BRR</name>
            <displayName>GPIOC_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>GPIOD</name>
        <description>GPIOD address block description</description>
		<groupName>GPIO</groupName>
        <baseAddress>0x50000C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOD_MODER</name>
            <displayName>GPIOD_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xEBFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_OTYPER</name>
            <displayName>GPIOD_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_OSPEEDR</name>
            <displayName>GPIOD_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_PUPDR</name>
            <displayName>GPIOD_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x24000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_IDR</name>
            <displayName>GPIOD_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_ODR</name>
            <displayName>GPIOD_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_BSRR</name>
            <displayName>GPIOD_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_LCKR</name>
            <displayName>GPIOD_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
LOCK key write sequence:
WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’ (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the lock.
After the first lock sequence on any bit of the port, any read access on the LCKK bit returns ‘1’ until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_AFRL</name>
            <displayName>GPIOD_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_AFRH</name>
            <displayName>GPIOD_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOD_BRR</name>
            <displayName>GPIOD_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>GPIOF</name>
        <description>GPIOF address block description</description>
		<groupName>GPIO</groupName>
        <baseAddress>0x50001400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOF_MODER</name>
            <displayName>GPIOF_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xEBFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to set the I/O to one of four operating modes.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_OTYPER</name>
            <displayName>GPIOF_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output type.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_OSPEEDR</name>
            <displayName>GPIOF_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration for I/O y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
The FT_c GPIOs cannot be set to high speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Very low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_PUPDR</name>
            <displayName>GPIOF_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x24000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_IDR</name>
            <displayName>GPIOF_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_ODR</name>
            <displayName>GPIOF_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_BSRR</name>
            <displayName>GPIOF_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.
Note: If both BSx and BRx are set, BSx has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODRx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODRx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_LCKR</name>
            <displayName>GPIOF_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is ‘0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
LOCK key write sequence:
WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’ (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the lock.
After the first lock sequence on any bit of the port, any read access on the LCKK bit returns ‘1’ until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_AFRL</name>
            <displayName>GPIOF_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x pin y (y = 0 to 7)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_AFRH</name>
            <displayName>GPIOF_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x, I/O y (y = 8 to 15)
These bits are written by software to configure alternate function I/Os</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOF_BRR</name>
            <displayName>GPIOF_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O y (y = 15 to 0)
These bits are write-only. A read operation always returns 0x0000.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODx bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODx bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>I2C</name>
        <description>I2C register block</description>
		<groupName>I2C</groupName>
        <baseAddress>0x40005400</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>I2C</name>
          <description>global interrupt (combined with EXTI 23)</description>
          <value>23</value>
        </interrupt>
        <registers>
          <register>
            <name>I2C_CR1</name>
            <displayName>I2C_CR1</displayName>
            <description>I2C control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Peripheral enable
Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Peripheral disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Peripheral enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXIE</name>
                <description>TX Interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmit (TXIS) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit (TXIS) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXIE</name>
                <description>RX Interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive (RXNE) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive (RXNE) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRIE</name>
                <description>Address match Interrupt enable (slave only)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Address match (ADDR) interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address match (ADDR) interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACKIE</name>
                <description>Not acknowledge received Interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not acknowledge (NACKF) received interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Not acknowledge (NACKF) received interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPIE</name>
                <description>Stop detection Interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Stop detection (STOPF) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop detection (STOPF) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transfer Complete interrupt enable
Note: Any of these events generate an interrupt:
Transfer Complete (TC)
Transfer Complete Reload (TCR)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transfer Complete interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transfer Complete interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRIE</name>
                <description>Error interrupts enable
Note: Any of these errors generate an interrupt:
Arbitration Loss (ARLO)
Bus Error detection (BERR)
Overrun/Underrun (OVR)
Timeout detection (TIMEOUT)
PEC error detection (PECERR)
Alert pin event detection (ALERT)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error detection interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error detection interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DNF</name>
                <description>Digital noise filter
These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK
...
Note: If the analog filter is also enabled, the digital filter is added to the analog filter.
This filter can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Digital filter disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Digital filter enabled and filtering capability up to 1 tI2CCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>digital filter enabled and filtering capability up to15 tI2CCLK</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANFOFF</name>
                <description>Analog noise filter OFF
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog noise filter enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog noise filter disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>DMA transmission requests enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXDMAEN</name>
                <description>DMA reception requests enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBC</name>
                <description>Slave byte control
This bit is used to enable hardware byte control in slave mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave byte control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave byte control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NOSTRETCH</name>
                <description>Clock stretching disable
This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Clock stretching enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clock stretching disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUPEN</name>
                <description>Wakeup from Stop mode enable
Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
Note: WUPEN can be set only when DNF = ‘0000’</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup from Stop mode disable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup from Stop mode enable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GCEN</name>
                <description>General call enable</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>General call disabled. Address 0b00000000 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General call enabled. Address 0b00000000 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBHEN</name>
                <description>SMBus host address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Host address disabled. Address 0b0001000x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Host address enabled. Address 0b0001000x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBDEN</name>
                <description>SMBus device default address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Device default address disabled. Address 0b1100001x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Device default address enabled. Address 0b1100001x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALERTEN</name>
                <description>SMBus alert enable
Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK). </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECEN</name>
                <description>PEC enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PEC calculation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC calculation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_CR2</name>
            <displayName>I2C_CR2</displayName>
            <description>I2C control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SADD</name>
                <description>Slave address (master mode)
In 7-bit addressing mode (ADD10 = 0):
SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.
In 10-bit addressing mode (ADD10 = 1):
SADD[9:0] should be written with the 10-bit slave address to be sent.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_WRN</name>
                <description>Transfer direction (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Master requests a write transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master requests a read transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD10</name>
                <description>10-bit addressing mode (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master operates in 7-bit addressing mode,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master operates in 10-bit addressing mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HEAD10R</name>
                <description>10-bit address header only read direction (master receiver mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START</name>
                <description>Start generation
This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.
If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.
Otherwise setting this bit generates a START condition once the bus is free.
Note: Writing ‘0’ to this bit has no effect.
The START bit can be set even if the bus is BUSY or I2C is in slave mode.
This bit has no effect when RELOAD is set.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Start generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Restart/Start generation:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>Stop generation (master mode)
The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.
In Master Mode:
Note: Writing ‘0’ to this bit has no effect.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Stop generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop generation after current byte transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACK</name>
                <description>NACK generation (slave mode)
The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.
Note: Writing ‘0’ to this bit has no effect.
This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.
When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.
When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an ACK is sent after current received byte.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a NACK is sent after current received byte.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBYTES</name>
                <description>Number of bytes
The number of bytes to be transmitted/received is programmed there. This field is don’t care in slave mode with SBC=0.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD</name>
                <description>NBYTES reload mode
This bit is set and cleared by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTOEND</name>
                <description>Automatic end mode (master mode)
This bit is set and cleared by software.
Note: This bit has no effect in slave mode or when the RELOAD bit is set.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECBYTE</name>
                <description>Packet error checking byte
This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.
Note: Writing ‘0’ to this bit has no effect.
This bit has no effect when RELOAD is set.
This bit has no effect is slave mode when SBC=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No PEC transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC transmission/reception is requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR1</name>
            <displayName>I2C_OAR1</displayName>
            <description>I2C own address 1 register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA1</name>
                <description>Interface own slave address
7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.
10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.
Note: These bits can be written only when OA1EN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA1MODE</name>
                <description>Own Address 1 10-bit mode
Note: This bit can be written only when OA1EN=0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 is a 7-bit address.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 is a 10-bit address.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA1EN</name>
                <description>Own Address 1 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 disabled. The received slave address OA1 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 enabled. The received slave address OA1 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR2</name>
            <displayName>I2C_OAR2</displayName>
            <description>I2C own address 2 register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA2</name>
                <description>Interface address
7-bit addressing mode: 7-bit address
Note: These bits can be written only when OA2EN=0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA2MSK</name>
                <description>Own Address 2 masks
Note: These bits can be written only when OA2EN=0.
As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No mask</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OA2[1] is masked and don’t care. Only OA2[7:2] are compared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>OA2[2:1] are masked and don’t care. Only OA2[7:3] are compared.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>OA2[3:1] are masked and don’t care. Only OA2[7:4] are compared.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>OA2[4:1] are masked and don’t care. Only OA2[7:5] are compared.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>OA2[5:1] are masked and don’t care. Only OA2[7:6] are compared.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>OA2[6:1] are masked and don’t care. Only OA2[7] is compared.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>OA2[7:1] are masked and don’t care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA2EN</name>
                <description>Own Address 2 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 2 disabled. The received slave address OA2 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 2 enabled. The received slave address OA2 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMINGR</name>
            <displayName>I2C_TIMINGR</displayName>
            <description>I2C timing register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SCLL</name>
                <description>SCL low period (master mode)
This field is used to generate the SCL low period in master mode.
tSCLL = (SCLL+1) x tPRESC
Note: SCLL is also used to generate tBUF and tSU:STA timings.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLH</name>
                <description>SCL high period (master mode)
This field is used to generate the SCL high period in master mode.
tSCLH = (SCLH+1) x tPRESC
Note: SCLH is also used to generate tSU:STO and tHD:STA timing.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SDADEL</name>
                <description>Data hold time
This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL.
tSDADEL= SDADEL x tPRESC
Note: SDADEL is used to generate tHD:DAT timing.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLDEL</name>
                <description>Data setup time
This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL.
tSCLDEL = (SCLDEL+1) x tPRESC
Note: tSCLDEL is used to generate tSU:DAT timing.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESC</name>
                <description>Timing prescaler
This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to ) and for SCL high and low level counters (refer to ).
tPRESC = (PRESC+1) x tI2CCLK</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMEOUTR</name>
            <displayName>I2C_TIMEOUTR</displayName>
            <description>I2C timeout register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMEOUTA</name>
                <description>Bus Timeout A
This field is used to configure:
The SCL low timeout condition tTIMEOUT when TIDLE=0
tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK
The bus idle condition (both SCL and SDA high) when TIDLE=1
tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK
Note: These bits can be written only when TIMOUTEN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIDLE</name>
                <description>Idle clock timeout detection
Note: This bit can be written only when TIMOUTEN=0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMEOUTA is used to detect SCL low timeout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMOUTEN</name>
                <description>Clock timeout enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SCL timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMEOUTB</name>
                <description>Bus timeout B
This field is used to configure the cumulative clock extension timeout:
In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected
In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected
tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK
Note: These bits can be written only when TEXTEN=0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TEXTEN</name>
                <description>Extended clock timeout enable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Extended clock timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ISR</name>
            <displayName>I2C_ISR</displayName>
            <description>I2C interrupt and status register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty (transmitters)
This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.
This bit can be written to ‘1’ by software in order to flush the transmit data register I2C_TXDR.
Note: This bit is set by hardware when PE=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TXIS</name>
                <description>Transmit interrupt status (transmitters)
This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register.
This bit can be written to ‘1’ by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1).
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RXNE</name>
                <description>Receive data register not empty (receivers)
This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ADDR</name>
                <description>Address matched (slave mode)
This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>NACKF</name>
                <description>Not Acknowledge received flag
This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STOPF</name>
                <description>Stop detection flag
This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:
either as a master, provided that the STOP condition is generated by the peripheral.
or as a slave, provided that the peripheral has been addressed previously during this transfer.
It is cleared by software by setting the STOPCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TC</name>
                <description>Transfer Complete (master mode)
This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TCR</name>
                <description>Transfer Complete Reload
This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.
Note: This bit is cleared by hardware when PE=0.
This flag is only for master mode, or for slave mode when the SBC bit is set.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BERR</name>
                <description>Bus error
This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARLO</name>
                <description>Arbitration lost
This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OVR</name>
                <description>Overrun/Underrun (slave mode)
This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PECERR</name>
                <description>PEC Error in reception
This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout or tLOW detection flag
This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ALERT</name>
                <description>SMBus alert
This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Bus busy
This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE=0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIR</name>
                <description>Transfer direction (Slave mode)
This flag is updated when an address match event occurs (ADDR=1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Write transfer, slave enters receiver mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Read transfer, slave enters transmitter mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDCODE</name>
                <description>Address match code (Slave mode)
These bits are updated with the received address when an address match event occurs (ADDR = 1).
In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ICR</name>
            <displayName>I2C_ICR</displayName>
            <description>I2C interrupt clear register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDRCF</name>
                <description>Address matched flag clear
Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NACKCF</name>
                <description>Not Acknowledge flag clear
Writing 1 to this bit clears the NACKF flag in I2C_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>STOPCF</name>
                <description>STOP detection flag clear
Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>BERRCF</name>
                <description>Bus error flag clear
Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARLOCF</name>
                <description>Arbitration lost flag clear
Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>OVRCF</name>
                <description>Overrun/Underrun flag clear
Writing 1 to this bit clears the OVR flag in the I2C_ISR register.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PECCF</name>
                <description>PEC Error flag clear
Writing 1 to this bit clears the PECERR flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TIMOUTCF</name>
                <description>Timeout detection flag clear
Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ALERTCF</name>
                <description>Alert flag clear
Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_PECR</name>
            <displayName>I2C_PECR</displayName>
            <description>I2C PEC register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PEC</name>
                <description>Packet error checking register
This field contains the internal PEC when PECEN=1.
The PEC is cleared by hardware when PE=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_RXDR</name>
            <displayName>I2C_RXDR</displayName>
            <description>I2C receive data register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXDATA</name>
                <description>8-bit receive data
Data byte received from the I2C bus</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TXDR</name>
            <displayName>I2C_TXDR</displayName>
            <description>I2C transmit data register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXDATA</name>
                <description>8-bit transmit data
Data byte to be transmitted to the I2C bus
Note: These bits can be written only when TXE=1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>IWDG</name>
        <description>IWDG register block</description>
		<groupName>IWDG</groupName>
        <baseAddress>0x40003000</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>IWDG_KR</name>
            <displayName>IWDG_KR</displayName>
            <description>IWDG key register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Key value (write only, read 0x0000)
These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.
Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see )
Writing the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_PR</name>
            <displayName>IWDG_PR</displayName>
            <description>IWDG prescaler register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PR</name>
                <description>Prescaler divider
These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.
Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>divider /4</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>divider /8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>divider /16</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>divider /32</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>divider /64</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>divider /128</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>divider /256</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>divider /256</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_RLR</name>
            <displayName>IWDG_RLR</displayName>
            <description>IWDG reload register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RL</name>
                <description>Watchdog counter reload value
These bits are write access protected see . They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the . The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information.
The RVU bit in the  must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_SR</name>
            <displayName>IWDG_SR</displayName>
            <description>IWDG status register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PVU</name>
                <description>Watchdog prescaler value update
This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Prescaler value can be updated only when PVU bit is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RVU</name>
                <description>Watchdog counter reload value update
This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Reload value can be updated only when RVU bit is reset.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WVU</name>
                <description>Watchdog counter window value update
This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Window value can be updated only when WVU bit is reset.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_WINR</name>
            <displayName>IWDG_WINR</displayName>
            <description>IWDG window register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WIN</name>
                <description>Watchdog counter window value
These bits are write access protected, see , they contain the high limit of the window value to be compared with the downcounter.
To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0
The WVU bit in the  must be reset in order to be able to change the reload value.
Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>PWR</name>
        <description>PWR address block description</description>
		<groupName>PWR</groupName>
        <baseAddress>0x40007000</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>PWR_CR1</name>
            <displayName>PWR_CR1</displayName>
            <description>PWR control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000208</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LPMS</name>
                <description>Low-power mode selection
These bits select the low-power mode entered when CPU enters deepsleep mode.
1XX: Shutdown mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Stop mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Standby mode</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPD_STOP</name>
                <description>Flash memory powered down during Stop mode
This bit determines whether the Flash memory is put in power-down mode or remains in idle mode when the device enters Stop mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Flash memory idle</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Flash memory powered down</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPD_SLP</name>
                <description>Flash memory powered down during Sleep mode
This bit determines whether the Flash memory is put in power-down mode or remains in idle mode when the device enters Sleep mode.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Flash memory idle</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Flash memory powered down</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_CR3</name>
            <displayName>PWR_CR3</displayName>
            <description>PWR control register 3 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00008000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWUP1</name>
                <description>Enable WKUP1 wakeup pin
When this bit is set, the WKUP1 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit of the PWR_CR4 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWUP2</name>
                <description>Enable WKUP2 wakeup pin
When this bit is set, the WKUP2 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit of the PWR_CR4 register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWUP3</name>
                <description>Enable WKUP3 wakeup pin
When this bit is set, the WKUP3 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit of the PWR_CR4 register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWUP4</name>
                <description>Enable WKUP4 wakeup pin
When this bit is set, the WKUP4 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWUP6</name>
                <description>Enable WKUP6 wakeup pin
When this bit is set, the WKUP6 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured through WP6 bit in the PWR_CR4 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>APC</name>
                <description>Apply pull-up and pull-down configuration
This bit determines whether the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not applied</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Applied</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EIWUL</name>
                <description>Enable internal wakeup line
When set, a rising edge on the internal wakeup line triggers a wakeup event.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_CR4</name>
            <displayName>PWR_CR4</displayName>
            <description>PWR control register 4 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WP1</name>
                <description>WKUP1 wakeup pin polarity
WKUP1 external wakeup signal polarity (level or edge) to generate wakeup condition:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WP2</name>
                <description>WKUP2 wakeup pin polarity
WKUP2 external wakeup signal polarity (level or edge) to generate wakeup condition:</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WP3</name>
                <description>WKUP3 wakeup pin polarity
WKUP3 external wakeup signal polarity (level or edge) to generate wakeup condition:</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WP4</name>
                <description>WKUP4 wakeup pin polarity
WKUP4 external wakeup signal polarity (level or edge) to generate wakeup condition:</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WP6</name>
                <description>WKUP6 wakeup pin polarity
WKUP6 external wakeup signal polarity (level or edge) to generate wakeup condition:</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_SR1</name>
            <displayName>PWR_SR1</displayName>
            <description>PWR status register 1 </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WUF1</name>
                <description>Wakeup flag 1
This bit is set when a wakeup condition is detected on WKUP1 wakeup pin. It is cleared by setting the CWUF1 bit of the PWR_SCR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WUF2</name>
                <description>Wakeup flag 2
This bit is set when a wakeup condition is detected on WKUP2 wakeup pin. It is cleared by setting the CWUF2 bit of the PWR_SCR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WUF3</name>
                <description>Wakeup flag 3
This bit is set when a wakeup condition is detected on WKUP3 wakeup pin. It is cleared by setting the CWUF3 bit of the PWR_SCR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WUF4</name>
                <description>Wakeup flag 4
This bit is set when a wakeup condition is detected on WKUP4 wakeup pin. It is cleared by setting the CWUF4 bit of the PWR_SCR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WUF6</name>
                <description>Wakeup flag 6
This bit is set when a wakeup condition is detected on WKUP6 wakeup pin. It is cleared by setting the CWUF6 bit of the PWR_SCR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SBF</name>
                <description>Standby/Shutdown flag
This bit is set by hardware when the device enters Standby or Shutdown mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The device did not enter Standby or Shutdown mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The device entered Standby or Shutdown mode </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUFI</name>
                <description>Wakeup flag internal
This bit is set when a wakeup condition is detected on the internal wakeup line. It is cleared when all internal wakeup sources are cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_SR2</name>
            <displayName>PWR_SR2</displayName>
            <description>PWR status register 2 </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLASH_RDY</name>
                <description>Flash ready flag
This bit is set by hardware to indicate when the Flash memory is ready to be accessed after wakeup from power-down. To place the Flash memory in power-down, set either FPD_SLP or FPD_STP bit.
Note: If the system boots from SRAM, the user application must wait till FLASH_RDY bit is set, prior to jumping to Flash memory.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Flash memory in power-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Flash memory ready to be accessed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_SCR</name>
            <displayName>PWR_SCR</displayName>
            <description>PWR status clear register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CWUF1</name>
                <description>Clear wakeup flag 1
Setting this bit clears the WUF1 flag in the PWR_SR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CWUF2</name>
                <description>Clear wakeup flag 2
Setting this bit clears the WUF2 flag in the PWR_SR1 register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CWUF3</name>
                <description>Clear wakeup flag 3
Setting this bit clears the WUF3 flag in the PWR_SR1 register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CWUF4</name>
                <description>Clear wakeup flag 4
Setting this bit clears the WUF4 flag in the PWR_SR1 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CWUF6</name>
                <description>Clear wakeup flag 6
Setting this bit clears the WUF6 flag in the PWR_SR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CSBF</name>
                <description>Clear standby flag
Setting this bit clears the SBF flag in the PWR_SR1 register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PUCRA</name>
            <displayName>PWR_PUCRA</displayName>
            <description>PWR Port A pull-up control register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PU0</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU1</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU2</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU3</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU4</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU5</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU6</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU7</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU8</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU9</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU10</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU11</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU12</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU13</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU14</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU15</name>
                <description>Port A pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PDCRA</name>
            <displayName>PWR_PDCRA</displayName>
            <description>PWR Port A pull-down control register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PD0</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD1</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD2</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD3</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD4</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD5</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD6</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD7</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD8</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD9</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD10</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD11</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD12</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD13</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD14</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD15</name>
                <description>Port A pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PUCRB</name>
            <displayName>PWR_PUCRB</displayName>
            <description>PWR Port B pull-up control register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PU0</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU1</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU2</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU3</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU4</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU5</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU6</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU7</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU8</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU9</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU10</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU11</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU12</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU13</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU14</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU15</name>
                <description>Port B pull-up bit i (i = 15 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.
On STM32C011xx, only PU7 and PU6 are available</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PDCRB</name>
            <displayName>PWR_PDCRB</displayName>
            <description>PWR Port B pull-down control register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PD0</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD1</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD2</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD3</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD4</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD5</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD6</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD7</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD8</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD9</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD10</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD11</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD12</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD13</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD14</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD15</name>
                <description>Port B pull-down bit i (i = 15 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.
On STM32C011xx, only PD7 and PD6 are available</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PUCRC</name>
            <displayName>PWR_PUCRC</displayName>
            <description>PWR Port C pull-up control register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PU6</name>
                <description>Port C pull-up bit i (i = 15 to 13, 7 to 6)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.
On STM32C011xx, only PU15 and PU14 are available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU7</name>
                <description>Port C pull-up bit i (i = 15 to 13, 7 to 6)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.
On STM32C011xx, only PU15 and PU14 are available</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU13</name>
                <description>Port C pull-up bit i (i = 15 to 13, 7 to 6)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.
On STM32C011xx, only PU15 and PU14 are available</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU14</name>
                <description>Port C pull-up bit i (i = 15 to 13, 7 to 6)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.
On STM32C011xx, only PU15 and PU14 are available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU15</name>
                <description>Port C pull-up bit i (i = 15 to 13, 7 to 6)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.
On STM32C011xx, only PU15 and PU14 are available</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PDCRC</name>
            <displayName>PWR_PDCRC</displayName>
            <description>PWR Port C pull-down control register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PD6</name>
                <description>Port C pull-down bit i (i = 15, 14, 13, 7, 6)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.
On STM32C011xx, only PD15 and PD14 are available.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD7</name>
                <description>Port C pull-down bit i (i = 15, 14, 13, 7, 6)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.
On STM32C011xx, only PD15 and PD14 are available.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD13</name>
                <description>Port C pull-down bit i (i = 15, 14, 13, 7, 6)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.
On STM32C011xx, only PD15 and PD14 are available.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD14</name>
                <description>Port C pull-down bit i (i = 15, 14, 13, 7, 6)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.
On STM32C011xx, only PD15 and PD14 are available.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD15</name>
                <description>Port C pull-down bit i (i = 15, 14, 13, 7, 6)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.
On STM32C011xx, only PD15 and PD14 are available.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PUCRD</name>
            <displayName>PWR_PUCRD</displayName>
            <description>PWR Port D pull-up control register </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PU0</name>
                <description>Port D pull-up bit i (i = 3 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU1</name>
                <description>Port D pull-up bit i (i = 3 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU2</name>
                <description>Port D pull-up bit i (i = 3 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU3</name>
                <description>Port D pull-up bit i (i = 3 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PDCRD</name>
            <displayName>PWR_PDCRD</displayName>
            <description>PWR Port D pull-down control register </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PD0</name>
                <description>Port D pull-down bit i (i = 3 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD1</name>
                <description>Port D pull-down bit i (i = 3 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD2</name>
                <description>Port D pull-down bit i (i = 3 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD3</name>
                <description>Port D pull-down bit i (i = 3 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PUCRF</name>
            <displayName>PWR_PUCRF</displayName>
            <description>PWR Port F pull-up control register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PU0</name>
                <description>Port F pull-up bit i (i = 2 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.
On STM32C011xx, only PU2 is available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU1</name>
                <description>Port F pull-up bit i (i = 2 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.
On STM32C011xx, only PU2 is available.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PU2</name>
                <description>Port F pull-up bit i (i = 2 to 0)
Setting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.
On STM32C011xx, only PU2 is available.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_PDCRF</name>
            <displayName>PWR_PDCRF</displayName>
            <description>PWR Port F pull-down control register </description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PD0</name>
                <description>Port F pull-down bit i (i = 2 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.
On STM32C011xx, only PD2 is available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD1</name>
                <description>Port F pull-down bit i (i = 2 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.
On STM32C011xx, only PD2 is available.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PD2</name>
                <description>Port F pull-down bit i (i = 2 to 0)
Setting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.
On STM32C011xx, only PD2 is available.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>RCC</name>
        <description>RCC address block description</description>
		<groupName>RCC</groupName>
        <baseAddress>0x40021000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>RCC</name>
          <description>RCC global interrupt</description>
          <value>4</value>
        </interrupt>
        <registers>
          <register>
            <name>RCC_CR</name>
            <displayName>RCC_CR</displayName>
            <description>RCC clock control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000500</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYSDIV</name>
                <description>System clock division factor
This bitfield controlled by software sets the division factor of the system clock divider to produce SYSCLK clock:</description>
                <bitOffset>2</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 (reset value)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIKERDIV</name>
                <description>HSI48 kernel clock division factor
This bitfield controlled by software sets the division factor of the kernel clock divider to produce HSIKER clock:</description>
                <bitOffset>5</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 (reset value)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSION</name>
                <description>HSI48 clock enable
Set and cleared by software and hardware, with hardware taking priority.
Kept low by hardware as long as the device is in a low-power mode.
Kept high by hardware as long as the system is clocked with a clock derived from HSI48. This includes the exit from low-power modes and the system clock fall-back to HSI48 upon failing HSE oscillator clock selected as system clock source.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIKERON</name>
                <description>HSI48 always-enable for peripheral kernels.
Set and cleared by software.
Setting the bit activates the HSI48 oscillator in Run and Stop modes, regardless of the HSION bit state. The HSI48 clock can only feed USART1, USART2, and I2C1 peripherals configured with HSI48 as kernel clock.
Note: Keeping the HSI48 active in Stop mode allows speeding up the serial interface communication as the HSI48 clock is ready immediately upon exiting Stop mode.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI48 oscillator enable depends on the HSION bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI48 oscillator is active in Run and Stop modes</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDY</name>
                <description>HSI48 clock ready flag
Set by hardware when the HSI48 oscillator is enabled through HSION and ready to use (stable).
Note: Upon clearing HSION, HSIRDY goes low after six HSI48 clock cycles.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not ready</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIDIV</name>
                <description>HSI48 clock division factor
This bitfield controlled by software sets the division factor of the HSI48 clock divider to produce HSISYS clock:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>4 (reset value)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>16</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>32</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>64</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>128</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEON</name>
                <description>HSE clock enable
Set and cleared by software.
Cleared by hardware to stop the HSE oscillator when entering Stop, or Standby, or Shutdown mode. This bit cannot be cleared if the HSE oscillator is used directly or indirectly as the system clock.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDY</name>
                <description>HSE clock ready flag
Set by hardware to indicate that the HSE oscillator is stable and ready for use.
Note: Upon clearing HSEON, HSERDY goes low after six HSE clock cycles.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not ready</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Ready </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEBYP</name>
                <description>HSE crystal oscillator bypass
Set and cleared by software.
When the bit is set, the internal HSE oscillator is bypassed for use of an external clock. The external clock must then be enabled with the HSEON bit set. Write access to the bit is only effective when the HSE oscillator is disabled.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No bypass</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bypass</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSSON</name>
                <description>Clock security system enable
Set by software to enable the clock security system. When the bit is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. The bit is cleared by hardware upon reset.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_ICSCR</name>
            <displayName>RCC_ICSCR</displayName>
            <description>RCC internal clock source calibration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00004000</resetValue>
            <resetMask>0xFFFFFF00</resetMask>
            <fields>
              <field>
                <name>HSICAL</name>
                <description>HSI48 clock calibration
This bitfield directly acts on the HSI48 clock frequency. Its value is a sum of an internal factory-programmed number and the value of the HSITRIM[6:0] bitfield. In the factory, the internal number is set to calibrate the HSI48 clock frequency to 48 MHz (with HSITRIM[6:0] left at its reset value). Refer to the device datasheet for HSI48 calibration accuracy and for the frequency trimming granularity.
Note: The trimming effect presents discontinuities at HSICAL[7:0] multiples of 64.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HSITRIM</name>
                <description>HSI48 clock trimming
The value of this bitfield contributes to the HSICAL[7:0] bitfield value.
It allows HSI48 clock frequency user trimming.
The HSI48 frequency accuracy as stated in the device datasheet applies when this bitfield is left at its reset value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CFGR</name>
            <displayName>RCC_CFGR</displayName>
            <description>RCC clock configuration register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SW</name>
                <description>System clock switch
This bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows:
Others: Reserved
The setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, or Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSISYS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LSI</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>LSE</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWS</name>
                <description>System clock switch status
This bitfield is controlled by hardware to indicate the clock source used as system clock:
Others: Reserved</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSISYS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LSI</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>LSE</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HPRE</name>
                <description>AHB prescaler
This bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows:
0xxx: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>2</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>4</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>8</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>16</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>64</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>128</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>256</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>512</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PPRE</name>
                <description>APB prescaler
This bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows:
0xx: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>8</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO2SEL</name>
                <description>Microcontroller clock output 2 clock selector
This bitfield is controlled by software. It sets the clock selector for MCO2 output as follows:
This bitfield is controlled by software. It sets the clock selector for MCO output as follows:
Note: This clock output may have some truncated cycles at startup or during MCO2 clock source switching.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock, MCO output disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SYSCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSI48</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>HSE</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>LSI</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>LSE</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO2PRE</name>
                <description>Microcontroller clock output 2 prescaler
This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows:
...
It is highly recommended to set this field before the MCO2 output is enabled.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>128</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCOSEL</name>
                <description>Microcontroller clock output clock selector
This bitfield is controlled by software. It sets the clock selector for MCO output as follows:
Note: This clock output may have some truncated cycles at startup or during MCO clock source switching. Any other value means no clock on MCO.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock, MCO output disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SYSCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSI48</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>HSE</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>LSI</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>LSE</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCOPRE</name>
                <description>Microcontroller clock output prescaler
This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows:
...
It is highly recommended to set this field before the MCO output is enabled.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>128</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CIER</name>
            <displayName>RCC_CIER</displayName>
            <description>RCC clock interrupt enable register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYIE</name>
                <description>LSI ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYIE</name>
                <description>LSE ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYIE</name>
                <description>HSI16 ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYIE</name>
                <description>HSE ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CIFR</name>
            <displayName>RCC_CIFR</displayName>
            <description>RCC clock interrupt flag register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYF</name>
                <description>LSI ready interrupt flag
This flag indicates a pending interrupt upon LSE clock getting ready.
Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set.
Cleared by software setting the LSIRDYC bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYF</name>
                <description>LSE ready interrupt flag
This flag indicates a pending interrupt upon LSE clock getting ready.
Set by hardware when the LSE clock becomes stable and LSERDYDIE is set.
Cleared by software setting the LSERDYC bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYF</name>
                <description>HSI16 ready interrupt flag
This flag indicates a pending interrupt upon HSI16 clock getting ready.
Set by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in response to setting the HSION (refer to ). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated.
Cleared by software setting the HSIRDYC bit.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYF</name>
                <description>HSE ready interrupt flag
This flag indicates a pending interrupt upon HSE clock getting ready.
Set by hardware when the HSE clock becomes stable and HSERDYIE is set.
Cleared by software setting the HSERDYC bit.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Iterrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSSF</name>
                <description>HSE clock security system interrupt flag
This flag indicates a pending interrupt upon HSE clock failure.
Set by hardware when a failure is detected in the HSE oscillator.
Cleared by software setting the CSSC bit.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSF</name>
                <description>LSE clock security system interrupt flag
This flag indicates a pending interrupt upon LSE clock failure.
Set by hardware when a failure is detected in the LSE oscillator.
Cleared by software by setting the LSECSSC bit.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CICR</name>
            <displayName>RCC_CICR</displayName>
            <description>RCC clock interrupt clear register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYC</name>
                <description>LSI ready interrupt clear
This bit is set by software to clear the LSIRDYF flag.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear LSIRDYF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYC</name>
                <description>LSE ready interrupt clear
This bit is set by software to clear the LSERDYF flag.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear LSERDYF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYC</name>
                <description>HSI16 ready interrupt clear
This bit is set software to clear the HSIRDYF flag.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear HSIRDYF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYC</name>
                <description>HSE ready interrupt clear
This bit is set by software to clear the HSERDYF flag.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear HSERDYF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSSC</name>
                <description>Clock security system interrupt clear
This bit is set by software to clear the HSECSSF flag.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear CSSF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSC</name>
                <description>LSE Clock security system interrupt clear
This bit is set by software to clear the LSECSSF flag.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear LSECSSF flag</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_IOPRSTR</name>
            <displayName>RCC_IOPRSTR</displayName>
            <description>RCC I/O port reset register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOARST</name>
                <description>I/O port A reset
This bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I/O port A</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBRST</name>
                <description>I/O port B reset
This bit is set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I/O port B</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCRST</name>
                <description>I/O port C reset
This bit is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I/O port C</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODRST</name>
                <description>I/O port D reset
This bit is set and cleared by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I/O port D</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOFRST</name>
                <description>I/O port F reset
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I/O port F</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHBRSTR</name>
            <displayName>RCC_AHBRSTR</displayName>
            <description>RCC AHB peripheral reset register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA1RST</name>
                <description>DMA1 and DMAMUX reset
Set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset DMA1 and DMAMUX</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASHRST</name>
                <description>Flash memory interface reset
Set and cleared by software.
This bit can only be set when the Flash memory is in power down mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset Flash memory interface</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCRST</name>
                <description>CRC reset
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset CRC</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBRSTR1</name>
            <displayName>RCC_APBRSTR1</displayName>
            <description>RCC APB peripheral reset register 1 </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM3RST</name>
                <description>TIM3 timer reset
Set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset TIM3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2RST</name>
                <description>USART2 reset
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset USART2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1RST</name>
                <description>I2C1 reset
Set and cleared by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset I2C1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBGRST</name>
                <description>Debug support reset
Set and cleared by software.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset DBG</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWRRST</name>
                <description>Power interface reset
Set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset PWR</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBRSTR2</name>
            <displayName>RCC_APBRSTR2</displayName>
            <description>RCC APB peripheral reset register 2 </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYSCFGRST</name>
                <description>SYSCFG reset
Set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset SYSCFG</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM1RST</name>
                <description>TIM1 timer reset
Set and cleared by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset TIM1 timer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1RST</name>
                <description>SPI1 reset
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset SPI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1RST</name>
                <description>USART1 reset
Set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset USART1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM14RST</name>
                <description>TIM14 timer reset
Set and cleared by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset TIM14 timer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16RST</name>
                <description>TIM16 timer reset
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset TIM16 timer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17RST</name>
                <description>TIM16 timer reset
Set and cleared by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset TIM17 timer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCRST</name>
                <description>ADC reset
Set and cleared by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset ADC</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_IOPENR</name>
            <displayName>RCC_IOPENR</displayName>
            <description>RCC I/O port clock enable register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOAEN</name>
                <description>I/O port A clock enable
This bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBEN</name>
                <description>I/O port B clock enable
This bit is set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCEN</name>
                <description>I/O port C clock enable
This bit is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODEN</name>
                <description>I/O port D clock enable
This bit is set and cleared by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOFEN</name>
                <description>I/O port F clock enable
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHBENR</name>
            <displayName>RCC_AHBENR</displayName>
            <description>RCC AHB peripheral clock enable register </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000100</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA1EN</name>
                <description>DMA1 and DMAMUX clock enable
Set and cleared by software.
DMAMUX is enabled as long as at least one DMA peripheral is enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASHEN</name>
                <description>Flash memory interface clock enable
Set and cleared by software.
This bit can only be cleared when the Flash memory is in power down mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCEN</name>
                <description>CRC clock enable
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBENR1</name>
            <displayName>RCC_APBENR1</displayName>
            <description>RCC APB peripheral clock enable register 1 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM3EN</name>
                <description>TIM3 timer clock enable
Set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCAPBEN</name>
                <description>RTC APB clock enable
Set and cleared by software.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGEN</name>
                <description>WWDG clock enable
Set by software to enable the window watchdog clock. Cleared by hardware system reset
This bit can also be set by hardware if the WWDG_SW option bit is 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2EN</name>
                <description>USART2 clock enable
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1EN</name>
                <description>I2C1 clock enable
Set and cleared by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBGEN</name>
                <description>Debug support clock enable
Set and cleared by software.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWREN</name>
                <description>Power interface clock enable
Set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBENR2</name>
            <displayName>RCC_APBENR2</displayName>
            <description>RCC APB peripheral clock enable register 2</description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYSCFGEN</name>
                <description>SYSCFG clock enable
Set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM1EN</name>
                <description>TIM1 timer clock enable
Set and cleared by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1EN</name>
                <description>SPI1 clock enable
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1EN</name>
                <description>USART1 clock enable
Set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM14EN</name>
                <description>TIM14 timer clock enable
Set and cleared by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16EN</name>
                <description>TIM16 timer clock enable
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17EN</name>
                <description>TIM16 timer clock enable
Set and cleared by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCEN</name>
                <description>ADC clock enable
Set and cleared by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_IOPSMENR</name>
            <displayName>RCC_IOPSMENR</displayName>
            <description>RCC I/O port in Sleep mode clock enable register </description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOASMEN</name>
                <description>I/O port A clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBSMEN</name>
                <description>I/O port B clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCSMEN</name>
                <description>I/O port C clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODSMEN</name>
                <description>I/O port D clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOFSMEN</name>
                <description>I/O port F clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHBSMENR</name>
            <displayName>RCC_AHBSMENR</displayName>
            <description>RCC AHB peripheral clock enable in Sleep/Stop mode register	</description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00051303</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA1SMEN</name>
                <description>DMA1 and DMAMUX clock enable during Sleep mode
Set and cleared by software.
Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASHSMEN</name>
                <description>Flash memory interface clock enable during Sleep mode
Set and cleared by software.
This bit can be activated only when the Flash memory is in power down mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAMSMEN</name>
                <description>SRAM clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCSMEN</name>
                <description>CRC clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBSMENR1</name>
            <displayName>RCC_APBSMENR1</displayName>
            <description>RCC APB peripheral clock enable in Sleep/Stop mode register 1	</description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x18EF7F36</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM3SMEN</name>
                <description>TIM3 timer clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCAPBSMEN</name>
                <description>RTC APB clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGSMEN</name>
                <description>WWDG clock enable during Sleep and Stop modes
Set and cleared by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2SMEN</name>
                <description>USART2 clock enable during Sleep and Stop modes
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1SMEN</name>
                <description>I2C1 clock enable during Sleep and Stop modes
Set and cleared by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBGSMEN</name>
                <description>Debug support clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWRSMEN</name>
                <description>Power interface clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APBSMENR2</name>
            <displayName>RCC_APBSMENR2</displayName>
            <description>RCC APB peripheral clock enable in Sleep/Stop mode register 2	</description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x0017D801</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYSCFGSMEN</name>
                <description>SYSCFG clock enable during Sleep and Stop modes
Set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM1SMEN</name>
                <description>TIM1 timer clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1SMEN</name>
                <description>SPI1 clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1SMEN</name>
                <description>USART1 clock enable during Sleep and Stop modes
Set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM14SMEN</name>
                <description>TIM14 timer clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16SMEN</name>
                <description>TIM16 timer clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17SMEN</name>
                <description>TIM16 timer clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCSMEN</name>
                <description>ADC clock enable during Sleep mode
Set and cleared by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR</name>
            <displayName>RCC_CCIPR</displayName>
            <description>RCC peripherals independent clock configuration register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>USART1SEL</name>
                <description>USART1 clock source selection
This bitfield is controlled by software to select USART1 clock source as follows:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PCLK</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SYSCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSIKER</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LSE</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1SEL</name>
                <description>I2C1 clock source selection
This bitfield is controlled by software to select I2C1 clock source as follows:</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PCLK </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SYSCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSIKER</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2S1SEL</name>
                <description>I2S1 clock source selection
This bitfield is controlled by software to select I2S1 clock source as follows:</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SYSCLK</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSIKER</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>I2S_CKIN</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCSEL</name>
                <description>ADCs clock source selection
This bitfield is controlled by software to select the clock source for ADC:</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>System clock</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSIKER</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CSR1</name>
            <displayName>RCC_CSR1</displayName>
            <description>RCC control/status register 1 </description>
            <addressOffset>0x5c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSEON</name>
                <description>LSE oscillator enable
Set and cleared by software to enable LSE oscillator:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDY</name>
                <description>LSE oscillator ready
Set and cleared by hardware to indicate when the external 32 kHz oscillator is ready (stable):
After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not ready</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSEBYP</name>
                <description>LSE oscillator bypass
Set and cleared by software to bypass the LSE oscillator (in debug mode).
This bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not bypassed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bypassed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSEDRV</name>
                <description>LSE oscillator drive capability
Set by software to select the LSE oscillator drive capability as follows:
Applicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low driving capability</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium-low driving capability</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>medium-high driving capability</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high driving capability </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSON</name>
                <description>CSS on LSE enable
Set by software to enable the clock security system on LSE (32 kHz) oscillator as follows:
LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected.
Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD
=1). In that case the software must disable the LSECSSON bit.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSD</name>
                <description>CSS on LSE failure Detection
Set by hardware to indicate when a failure is detected by the clock security system
on the external 32 kHz oscillator (LSE):</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No failure detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Failure detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCSEL</name>
                <description>RTC clock source selection
Set by software to select the clock source for the RTC as follows:
Once the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The RTCRST bit can be used to reset this bitfield to 00.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No clock</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LSI</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSE divided by 32</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCEN</name>
                <description>RTC clock enable
Set and cleared by software. The bit enables clock to RTC and TAMP.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCRST</name>
                <description>RTC domain software reset
Set and cleared by software to reset the RTC domain:</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSCOEN</name>
                <description>Low-speed clock output (LSCO) enable
Set and cleared by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSCOSEL</name>
                <description>Low-speed clock output selection
Set and cleared by software to select the low-speed output clock:</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSI</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CSR2</name>
            <displayName>RCC_CSR2</displayName>
            <description>RCC control/status register 2 </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>LSION</name>
                <description>LSI oscillator enable
Set and cleared by software to enable/disable the LSI oscillator:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSIRDY</name>
                <description>LSI oscillator ready
Set and cleared by hardware to indicate when the LSI oscillator is ready (stable):
After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not ready</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RMVF</name>
                <description>Remove reset flags
Set by software to clear the reset flags.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear reset flags</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OBLRSTF</name>
                <description>Option byte loader reset flag
Set by hardware when a reset from the Option byte loading occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No reset from Option byte loading occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset from Option byte loading occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINRSTF</name>
                <description>Pin reset flag
Set by hardware when a reset from the NRST pin occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No reset from NRST pin occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset from NRST pin occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWRRSTF</name>
                <description>BOR or POR/PDR flag
Set by hardware when a BOR or POR/PDR occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No BOR or POR occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BOR or POR occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SFTRSTF</name>
                <description>Software reset flag
Set by hardware when a software reset occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No software reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Software reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGRSTF</name>
                <description>Independent window watchdog reset flag
Set by hardware when an independent watchdog reset domain occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No independent watchdog reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Independent watchdog reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGRSTF</name>
                <description>Window watchdog reset flag
Set by hardware when a window watchdog reset occurs.
Cleared by setting the RMVF bit.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No window watchdog reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Window watchdog reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPWRRSTF</name>
                <description>Low-power reset flag
Set by hardware when a reset occurs due to illegal Stop, or Standby, or Shutdown mode entry.
Cleared by setting the RMVF bit.
This operates only if nRST_STOP, or nRST_STDBY or nRST_SHDW option bits are cleared.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No illegal mode reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Illegal mode reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>RTC</name>
        <description>RTC register block</description>
		<groupName>RTC</groupName>
        <baseAddress>0x40002800</baseAddress>  
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>RTC</name>
          <description>RTC interrupts (EXTI lines 19)</description>
          <value>2</value>
        </interrupt>
        <registers>
          <register>
            <name>RTC_TR</name>
            <displayName>RTC_TR</displayName>
            <description>RTC time register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SU</name>
                <description>Second units in BCD format</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ST</name>
                <description>Second tens in BCD format</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MNU</name>
                <description>Minute units in BCD format</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MNT</name>
                <description>Minute tens in BCD format</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HU</name>
                <description>Hour units in BCD format</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT</name>
                <description>Hour tens in BCD format</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PM</name>
                <description>AM/PM notation</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AM or 24-hour format</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PM</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_DR</name>
            <displayName>RTC_DR</displayName>
            <description>RTC date register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00002101</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DU</name>
                <description>Date units in BCD format</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DT</name>
                <description>Date tens in BCD format</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MU</name>
                <description>Month units in BCD format</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MT</name>
                <description>Month tens in BCD format</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDU</name>
                <description>Week day units
...</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>forbidden</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Monday</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Sunday</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>YU</name>
                <description>Year units in BCD format</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>YT</name>
                <description>Year tens in BCD format</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_SSR</name>
            <displayName>RTC_SSR</displayName>
            <description>RTC sub second register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SS</name>
                <description>Sub second value
SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:
Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1)
Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ICSR</name>
            <displayName>RTC_ICSR</displayName>
            <description>RTC initialization control and status register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000007</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ALRAWF</name>
                <description>Alarm A write flag
This bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
It is cleared by hardware in initialization mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A update not allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Alarm A update allowed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SHPF</name>
                <description>Shift operation pending
This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No shift operation is pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A shift operation is pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INITS</name>
                <description>Initialization status flag
This bit is set by hardware when the calendar year field is different from 0 (Power-on reset state).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calendar has not been initialized</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calendar has been initialized</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RSF</name>
                <description>Registers synchronization flag
This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.
It is cleared either by software or by hardware in initialization mode.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calendar shadow registers not yet synchronized</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calendar shadow registers synchronized</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INITF</name>
                <description>Initialization flag
When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calendar registers update is not allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calendar registers update is allowed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INIT</name>
                <description>Initialization mode</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Free running mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RECALPF</name>
                <description>Recalibration pending Flag
The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_PRER</name>
            <displayName>RTC_PRER</displayName>
            <description>RTC prescaler register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x007F00FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PREDIV_S</name>
                <description>Synchronous prescaler factor
This is the synchronous division factor:
ck_spre frequency = ck_apre frequency/(PREDIV_S+1)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PREDIV_A</name>
                <description>Asynchronous prescaler factor
This is the asynchronous division factor:
ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_CR</name>
            <displayName>RTC_CR</displayName>
            <description>RTC control register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSEDGE</name>
                <description>Timestamp event active edge
TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTC_TS input rising edge generates a timestamp event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTC_TS input falling edge generates a timestamp event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REFCKON</name>
                <description>RTC_REFIN reference clock detection enable (50 or 60 Hz)
Note: PREDIV_S must be 0x00FF.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTC_REFIN detection disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTC_REFIN detection enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BYPSHAD</name>
                <description>Bypass the shadow registers
Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FMT</name>
                <description>Hour format</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>24 hour/day format</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AM/PM hour format</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALRAE</name>
                <description>Alarm A enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Alarm A enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSE</name>
                <description>timestamp enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>timestamp disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>timestamp enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALRAIE</name>
                <description>Alarm A interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Alarm A interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSIE</name>
                <description>Timestamp interrupt enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timestamp interrupt disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timestamp interrupt enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD1H</name>
                <description>Add 1 hour (summer time change)
When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Adds 1 hour to the current time. This can be used for summer time change</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUB1H</name>
                <description>Subtract 1 hour (winter time change)
When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.
Setting this bit has no effect when current hour is 0.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Subtracts 1 hour to the current time. This can be used for winter time change.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKP</name>
                <description>Backup
This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COSEL</name>
                <description>Calibration output selection
When COE = 1, this bit selects which signal is output on CALIB.
These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calibration output is 512 Hz</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calibration output is 1 Hz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>POL</name>
                <description>Output polarity
This bit is used to configure the polarity of TAMPALRM output.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The pin is high when ALRAF is asserted (depending on OSEL[1:0]).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The pin is low when ALRAF is asserted (depending on OSEL[1:0]).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSEL</name>
                <description>Output selection
These bits are used to select the flag to be routed to TAMPALRM output.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Alarm A output enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COE</name>
                <description>Calibration output enable
This bit enables the CALIB output</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calibration output disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calibration output enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TAMPALRM_PU</name>
                <description>TAMPALRM pull-up enable</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up is applied on TAMPALRM output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A pull-up is applied on TAMPALRM output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TAMPALRM_TYPE</name>
                <description>TAMPALRM output type</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TAMPALRM is push-pull output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TAMPALRM is open-drain output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OUT2EN</name>
                <description>RTC_OUT2 output enable
Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows:
OUT2EN = 0: RTC output 2 disable
If OSEL ≠ 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1
If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1
OUT2EN = 1: RTC output 2 enable
If (OSEL ≠ 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2
If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2
If (OSEL≠ 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_WPR</name>
            <displayName>RTC_WPR</displayName>
            <description>RTC write protection register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Write protection key
This byte is written by software.
Reading this byte always returns 0x00.
Refer to  for a description of how to unlock RTC register write protection.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_CALR</name>
            <displayName>RTC_CALR</displayName>
            <description>RTC calibration register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CALM</name>
                <description>Calibration minus
The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm.
To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALW16</name>
                <description>Use a 16-second calibration cycle period
When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.
Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALW8</name>
                <description>Use an 8-second calibration cycle period
When CALW8 is set to 1, the 8-second calibration cycle period is selected.
Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALP</name>
                <description>Increase frequency of RTC by 488.5 ppm
This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 � CALP) - CALM.
Refer to .</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No RTCCLK pulses are added.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>One RTCCLK pulse is effectively inserted every 211 pulses (frequency increased by 488.5 ppm).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_SHIFTR</name>
            <displayName>RTC_SHIFTR</displayName>
            <description>RTC shift control register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SUBFS</name>
                <description>Subtract a fraction of a second
These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:
Delay (seconds) = SUBFS / (PREDIV_S + 1)
A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:
Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).
Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ADD1S</name>
                <description>Add one second
This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Add one second to the clock/calendar</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_TSTR</name>
            <displayName>RTC_TSTR</displayName>
            <description>RTC timestamp time register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SU</name>
                <description>Second units in BCD format.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ST</name>
                <description>Second tens in BCD format.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MNU</name>
                <description>Minute units in BCD format.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MNT</name>
                <description>Minute tens in BCD format.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HU</name>
                <description>Hour units in BCD format.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HT</name>
                <description>Hour tens in BCD format.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PM</name>
                <description>AM/PM notation</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AM or 24-hour format</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PM</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_TSDR</name>
            <displayName>RTC_TSDR</displayName>
            <description>RTC timestamp date register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DU</name>
                <description>Date units in BCD format</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DT</name>
                <description>Date tens in BCD format</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MU</name>
                <description>Month units in BCD format</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MT</name>
                <description>Month tens in BCD format</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WDU</name>
                <description>Week day units</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_TSSSR</name>
            <displayName>RTC_TSSSR</displayName>
            <description>RTC timestamp sub second register </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SS</name>
                <description>Sub second value
SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ALRMAR</name>
            <displayName>RTC_ALRMAR</displayName>
            <description>RTC alarm A register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SU</name>
                <description>Second units in BCD format.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ST</name>
                <description>Second tens in BCD format.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MSK1</name>
                <description>Alarm A seconds mask</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A set if the seconds match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Seconds don’t care in alarm A comparison</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MNU</name>
                <description>Minute units in BCD format</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MNT</name>
                <description>Minute tens in BCD format</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MSK2</name>
                <description>Alarm A minutes mask</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A set if the minutes match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Minutes don’t care in alarm A comparison</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HU</name>
                <description>Hour units in BCD format</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT</name>
                <description>Hour tens in BCD format</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PM</name>
                <description>AM/PM notation</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AM or 24-hour format</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PM</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSK3</name>
                <description>Alarm A hours mask</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A set if the hours match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Hours don’t care in alarm A comparison</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DU</name>
                <description>Date units or day in BCD format</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DT</name>
                <description>Date tens in BCD format</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDSEL</name>
                <description>Week day selection</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DU[3:0] represents the date units</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DU[3:0] represents the week day. DT[1:0] is don’t care.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSK4</name>
                <description>Alarm A date mask</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Alarm A set if the date/day match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Date/day don’t care in alarm A comparison</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ALRMASSR</name>
            <displayName>RTC_ALRMASSR</displayName>
            <description>RTC alarm A sub second register </description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SS</name>
                <description>Sub seconds value
This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MASKSS</name>
                <description>Mask the most-significant bits starting at this bit
2:	SS[14:2] are don’t care in alarm A comparison. Only SS[1:0] are compared.
3:	SS[14:3] are don’t care in alarm A comparison. Only SS[2:0] are compared.
...
12:	SS[14:12] are don’t care in alarm A comparison. SS[11:0] are compared.
13:	SS[14:13] are don’t care in alarm A comparison. SS[12:0] are compared.
14:	SS[14] is don’t care in alarm A comparison. SS[13:0] are compared.
15:	All 15 SS bits are compared and must match to activate alarm.
The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No comparison on sub seconds for alarm A. The alarm is set when the seconds unit is incremented (assuming that the rest of the fields match).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SS[14:1] are don’t care in alarm A comparison. Only SS[0] is compared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_SR</name>
            <displayName>RTC_SR</displayName>
            <description>RTC status register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ALRAF</name>
                <description>Alarm A flag
This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TSF</name>
                <description>Timestamp flag
This flag is set by hardware when a timestamp event occurs.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TSOVF</name>
                <description>Timestamp overflow flag
This flag is set by hardware when a timestamp event occurs while TSF is already set.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_MISR</name>
            <displayName>RTC_MISR</displayName>
            <description>RTC masked interrupt status register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ALRAMF</name>
                <description>Alarm A masked flag
This flag is set by hardware when the alarm A interrupt occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TSMF</name>
                <description>Timestamp masked flag
This flag is set by hardware when a timestamp interrupt occurs.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TSOVMF</name>
                <description>Timestamp overflow masked flag
This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_SCR</name>
            <displayName>RTC_SCR</displayName>
            <description>RTC status clear register </description>
            <addressOffset>0x5c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CALRAF</name>
                <description>Clear alarm A flag
Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTSF</name>
                <description>Clear timestamp flag
Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTSOVF</name>
                <description>Clear timestamp overflow flag
Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>SPI</name>
        <description>Serial peripheral interface</description>
		<groupName>SPI</groupName>
        <baseAddress>0x40013000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>SPI</name>
          <description>SPI/I2S global interrupt</description>
          <value>25</value>
        </interrupt>
        <registers>
          <register>
            <name>SPI_CR1</name>
            <displayName>SPI_CR1</displayName>
            <description>SPI control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CPHA</name>
                <description>Clock phase
Note: This bit should not be changed when communication is ongoing.
This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The first clock transition is the first data capture edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The second clock transition is the first data capture edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPOL</name>
                <description>Clock polarity
Note: This bit should not be changed when communication is ongoing.
This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CK to 0 when idle</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CK to 1 when idle</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSTR</name>
                <description>Master selection
Note: This bit should not be changed when communication is ongoing.
This bit is not used in I2S mode.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave configuration</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master configuration</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR</name>
                <description>Baud rate control
Note: These bits should not be changed when communication is ongoing.
These bits are not used in I2S mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fPCLK/2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fPCLK/4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fPCLK/8</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fPCLK/16</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fPCLK/32</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fPCLK/64</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fPCLK/128</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fPCLK/256</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPE</name>
                <description>SPI enable
Note: When disabling the SPI, follow the procedure described in SPI on page 1349.
This bit is not used in I2S mode.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Peripheral disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Peripheral enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSBFIRST</name>
                <description>Frame format
Note: 1. This bit should not be changed when communication is ongoing.
2. This bit is not used in I2S mode and SPI TI mode.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data is transmitted / received with the MSB first</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data is transmitted / received with the LSB first</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSI</name>
                <description>Internal slave select
This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.
Note: This bit is not used in I2S mode and SPI TI mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SSM</name>
                <description>Software slave management
When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.
Note: This bit is not used in I2S mode and SPI TI mode.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Software slave management disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Software slave management enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXONLY</name>
                <description>Receive only mode enabled.
This bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.
Note: This bit is not used in I2S mode.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full-duplex (Transmit and receive)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output disabled (Receive-only mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCL</name>
                <description>CRC length
This bit is set and cleared by software to select the CRC length.
Note: This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation.
This bit is not used in I2S mode.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>8-bit CRC length</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16-bit CRC length</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCNEXT</name>
                <description>Transmit CRC next
Note: This bit has to be written as soon as the last data is written in the SPI_DR register.
This bit is not used in I2S mode.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Next transmit value is from Tx buffer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Next transmit value is from Tx CRC register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCEN</name>
                <description>Hardware CRC calculation enable
Note: This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation.
This bit is not used in I2S mode.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC calculation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC calculation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIDIOE</name>
                <description>Output enable in bidirectional mode
This bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.
Note: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.
This bit is not used in I2S mode.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output disabled (receive-only mode) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output enabled (transmit-only mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIDIMODE</name>
                <description>Bidirectional data mode enable.
This bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.
Note: This bit is not used in I2S mode.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2-line unidirectional data mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1-line bidirectional data mode selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CR2</name>
            <displayName>SPI_CR2</displayName>
            <description>SPI control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000700</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>RXDMAEN</name>
                <description>Rx buffer DMA enable
When this bit is set, a DMA request is generated whenever the RXNE flag is set.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx buffer DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx buffer DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>Tx buffer DMA enable
When this bit is set, a DMA request is generated whenever the TXE flag is set.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx buffer DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx buffer DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSOE</name>
                <description>SS output enable
Note: This bit is not used in I2S mode and SPI TI mode.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SS output is disabled in master mode and the SPI interface can work in multimaster configuration</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SS output is enabled in master mode and when the SPI interface is enabled. The SPI interface cannot work in a multimaster environment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NSSP</name>
                <description>NSS pulse management
This bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.
It has no meaning if CPHA = ’1’, or FRF = ’1’.
Note: 1. This bit must be written only when the SPI is disabled (SPE=0).
2. This bit is not used in I2S mode and SPI TI mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No NSS pulse</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>NSS pulse generated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FRF</name>
                <description>Frame format
1 SPI TI mode
Note: This bit must be written only when the SPI is disabled (SPE=0).
This bit is not used in I2S mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI Motorola mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRIE</name>
                <description>Error interrupt enable
This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I2S mode).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error interrupt is masked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error interrupt is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNEIE</name>
                <description>RX buffer not empty interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXNE interrupt masked </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXEIE</name>
                <description>Tx buffer empty interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXE interrupt masked </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS</name>
                <description>Data size
These bits configure the data length for SPI transfers.
If software attempts to write one of the “Not used” values, they are forced to the value “0111”
(8-bit)
Note: These bits are not used in I2S mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Not used</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Not used</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4-bit</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5-bit</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6-bit</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7-bit</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8-bit</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>9-bit</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>10-bit</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>11-bit</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>12-bit</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>13-bit</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>14-bit</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>15-bit</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>16-bit</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FRXTH</name>
                <description>FIFO reception threshold
This bit is used to set the threshold of the RXFIFO that triggers an RXNE event
Note: This bit is not used in I2S mode.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXNE event is generated if the FIFO level is greater than or equal to 1/2 (16-bit)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXNE event is generated if the FIFO level is greater than or equal to 1/4 (8-bit)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LDMA_RX</name>
                <description>Last DMA transfer for reception
This bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =&lt; 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).
Note: Refer to  if the CRCEN bit is set.
This bit is not used in I�S mode.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Number of data to transfer is even</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Number of data to transfer is odd</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LDMA_TX</name>
                <description>Last DMA transfer for transmission
This bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =&lt; 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).
Note: Refer to  if the CRCEN bit is set.
This bit is not used in I�S mode.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Number of data to transfer is even</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Number of data to transfer is odd</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_SR</name>
            <displayName>SPI_SR</displayName>
            <description>SPI status register </description>
            <addressOffset>0x8</addressOffset>
            <size>16</size>
            <resetValue>0x00000002</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>RXNE</name>
                <description>Receive buffer not empty</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx buffer empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx buffer not empty</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXE</name>
                <description>Transmit buffer empty</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx buffer not empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx buffer empty</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHSIDE</name>
                <description>Channel side
Note: This bit is not used in SPI mode. It has no significance in PCM mode.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Channel Left has to be transmitted or has been received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Channel Right has to be transmitted or has been received</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDR</name>
                <description>Underrun flag
This flag is set by hardware and reset by a software sequence. Refer to page 1385 for the software sequence.
Note: This bit is not used in SPI mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No underrun occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Underrun occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCERR</name>
                <description>CRC error flag
Note: This flag is set by hardware and cleared by software writing 0.
This bit is not used in I2S mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC value received matches the SPI_RXCRCR value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC value received does not match the SPI_RXCRCR value</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODF</name>
                <description>Mode fault
This flag is set by hardware and reset by a software sequence. Refer to (MODF) on page 1359 for the software sequence.
Note: This bit is not used in I2S mode.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No mode fault occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Mode fault occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVR</name>
                <description>Overrun flag
This flag is set by hardware and reset by a software sequence. Refer to page 1385 for the software sequence.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BSY</name>
                <description>Busy flag
This flag is set and cleared by hardware.
Note: The BSY flag must be used with caution: refer to  and .</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI (or I2S) not busy</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI (or I2S) is busy in communication or Tx buffer is not empty</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FRE</name>
                <description>Frame format error
This flag is used for SPI in TI slave mode and I2S slave mode. Refer to error flags and .
This flag is set by hardware and reset when SPI_SR is read by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No frame format error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A frame format error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FRLVL</name>
                <description>FIFO reception level
These bits are set and cleared by hardware.
Note: These bits are not used in I�S mode and in SPI receive-only mode while CRC calculation is enabled.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1/4 FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>1/2 FIFO</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>FIFO full</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FTLVL</name>
                <description>FIFO transmission level
These bits are set and cleared by hardware.
Note: This bit is not used in I2S mode.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1/4 FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>1/2 FIFO</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>FIFO full (considered as FULL when the FIFO threshold is greater than 1/2)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_DR</name>
            <displayName>SPI_DR</displayName>
            <description>SPI data register </description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data register
Data received or to be transmitted
The data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See ).
Note: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CRCPR</name>
            <displayName>SPI_CRCPR</displayName>
            <description>SPI CRC polynomial register </description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000007</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CRCPOLY</name>
                <description>CRC polynomial register
This register contains the polynomial for the CRC calculation.
The CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_RXCRCR</name>
            <displayName>SPI_RXCRCR</displayName>
            <description>SPI Rx CRC register </description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>RXCRC</name>
                <description>Rx CRC register
When CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.
Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.
The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.
Note: A read to this register when the BSY Flag is set could return an incorrect value.
These bits are not used in I2S mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_TXCRCR</name>
            <displayName>SPI_TXCRCR</displayName>
            <description>SPI Tx CRC register </description>
            <addressOffset>0x18</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>TXCRC</name>
                <description>Tx CRC register
When CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.
Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.
The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.
Note: A read to this register when the BSY flag is set could return an incorrect value.
These bits are not used in I2S mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_I2SCFGR</name>
            <displayName>SPI_I2SCFGR</displayName>
            <description>SPI_I2S configuration register </description>
            <addressOffset>0x1c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CHLEN</name>
                <description>Channel length (number of bits per audio channel)
The bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.
Note: For correct operation, this bit should be configured when the I2S is disabled.
It is not used in SPI mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>16-bit wide</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>32-bit wide</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATLEN</name>
                <description>Data length to be transferred
Note: For correct operation, these bits should be configured when the I2S is disabled.
They are not used in SPI mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>16-bit data length</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>24-bit data length</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32-bit data length</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Not allowed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKPOL</name>
                <description>Inactive state clock polarity
Note: For correct operation, this bit should be configured when the I2S is disabled.
It is not used in SPI mode.
The bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS signals.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2S clock inactive state is low level</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2S clock inactive state is high level</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SSTD</name>
                <description>I2S standard selection
For more details on I2S standards, refer to
Note: For correct operation, these bits should be configured when the I2S is disabled.
They are not used in SPI mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2S Philips standard</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MSB justified standard (left justified)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LSB justified standard (right justified)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PCM standard</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCMSYNC</name>
                <description>PCM frame synchronization
Note: This bit has a meaning only if I2SSTD = 11 (PCM standard is used).
It is not used in SPI mode.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Short frame synchronization</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Long frame synchronization</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SCFG</name>
                <description>I2S configuration mode
Note: These bits should be configured when the I2S is disabled.
They are not used in SPI mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave - transmit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave - receive</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Master - transmit</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Master - receive</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SE</name>
                <description>I2S enable
Note: This bit is not used in SPI mode.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2S peripheral is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2S peripheral is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SMOD</name>
                <description>I2S mode selection
Note: This bit should be configured when the SPI is disabled.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI mode is selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2S mode is selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ASTRTEN</name>
                <description>Asynchronous start enable.
When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal.
When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and the appropriate level is detected on the WS signal.
Note: The appropriate transition is a falling edge on WS signal when I2S Philips Standard is used, or a rising edge for other standards.
The appropriate level is a low level on WS signal when I2S Philips Standard is used, or a high level for other standards.
Please refer to  for additional information.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The Asynchronous start is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The Asynchronous start is enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_I2SPR</name>
            <displayName>SPI_I2SPR</displayName>
            <description>SPI_I2S prescaler register </description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000002</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>I2SDIV</name>
                <description>I2S linear prescaler
I2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values.
Refer to .
Note: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode.
They are not used in SPI mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ODD</name>
                <description>Odd factor for the prescaler
Refer to .
Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.
It is not used in SPI mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Real divider value is = I2SDIV *2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Real divider value is = (I2SDIV * 2) + 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCKOE</name>
                <description>Master clock output enable
Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.
It is not used in SPI mode.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Master clock output is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master clock output is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>SYSCFG</name>
        <description>SYSCFG register block</description>
		<groupName>SYSCFG</groupName>
        <baseAddress>0x40010000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>SYSCFG_CFGR1</name>
            <displayName>SYSCFG_CFGR1</displayName>
            <description>SYSCFG configuration register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF0</resetMask>
            <fields>
              <field>
                <name>MEM_MODE</name>
                <description>Memory mapping selection bits
This bitfield controlled by software selects the memory internally mapped at the address 0x0000 0000. Its reset value is determined by the boot mode configuration. Refer to  for more details.
x0: Main Flash memory</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>System Flash memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Embedded SRAM</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PA11_RMP</name>
                <description>PA11 pin remapping
This bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remap (PA11)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remap (PA9)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PA12_RMP</name>
                <description>PA12 pin remapping
This bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remap (PA12)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remap (PA10)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IR_POL</name>
                <description>IR output polarity selection</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output of IRTIM (IR_OUT) is not inverted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output of IRTIM (IR_OUT) is inverted</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IR_MOD</name>
                <description>IR Modulation Envelope signal selection
This bitfield selects the signal for IR modulation envelope:</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM16</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>USART2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PB6_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PB6
This bit is set and cleared by software. It enables I2C FM+ driving capability on PB6 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PB7_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PB7
This bit is set and cleared by software. It enables I2C FM+ driving capability on PB7 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PB8_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PB8
This bit is set and cleared by software. It enables I2C FM+ driving capability on PB8 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PB9_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PB9
This bit is set and cleared by software. It enables I2C FM+ driving capability on PB9 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1_FMP</name>
                <description>Fast Mode Plus (FM+) enable for I2C1
This bit is set and cleared by software. It enables I2C FM+ driving capability on I/O ports configured as I2C1 through GPIOx_AFR registers.
With this bit in disable state, the I2C FM+ driving capability on I/O ports configured as I2C1 can be enabled through their corresponding I2Cx_FMP bit. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PA9_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PA9
This bit is set and cleared by software. It enables I2C FM+ driving capability on PA9 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PA10_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PA10
This bit is set and cleared by software. It enables I2C FM+ driving capability on PA10 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C_PC14_FMP</name>
                <description>Fast Mode Plus (FM+) enable for PC14
This bit is set and cleared by software. It enables I2C FM+ driving capability on PC14 I/O port.
With this bit in disable state, the I2C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I2C FM+ is enabled, the speed control is ignored.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_CFGR2</name>
            <displayName>SYSCFG_CFGR2</displayName>
            <description>SYSCFG configuration register 2 </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCKUP_LOCK</name>
                <description>Cortex&lt;Superscript&gt;�&lt;Default � Font&gt;-M0+ LOCKUP enable
This bit is set by software and cleared by system reset. When set, it enables the connection of Cortex&lt;Superscript&gt;�&lt;Default � Font&gt;-M0+ LOCKUP (HardFault) output to the TIM1/16/17 Break input.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_CFGR3</name>
            <displayName>SYSCFG_CFGR3</displayName>
            <description>SYSCFG configuration register 3 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PINMUX0</name>
                <description>Pin GPIO multiplexer 0
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved
Pin F2 of WLCSP14 package GPIO assignment
1x: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_1</name>
                    <description>PB7</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_1</name>
                    <description>PC14</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_F2</name>
                    <description>PA1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_F2</name>
                    <description>PA2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX1</name>
                <description>Pin GPIO multiplexer 1
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_4</name>
                    <description>PF2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_4</name>
                    <description>PA0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_4</name>
                    <description>PA1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_4</name>
                    <description>PA2</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_G3</name>
                    <description>PF2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_G3</name>
                    <description>PA0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX2</name>
                <description>Pin GPIO multiplexer 2
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved
1x: Reserved</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_5</name>
                    <description>PA8</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_5</name>
                    <description>PA11</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_J1</name>
                    <description>PA8</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_J1</name>
                    <description>PA11</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX3</name>
                <description>Pin GPIO multiplexer 3
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_8</name>
                    <description>PA14</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_8</name>
                    <description>PB6</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_STM32C011X___GPIO_ASSIGNED_TO_SO8_PIN_8</name>
                    <description>PC15</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_H2</name>
                    <description>PA5</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_H2</name>
                    <description>PA6</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX4</name>
                <description>Pin GPIO multiplexer 4
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved
1x: Reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_E2</name>
                    <description>PA7</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_E2</name>
                    <description>PA12</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_G1</name>
                    <description>PA7</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_G1</name>
                    <description>PA12</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX5</name>
                <description>Pin GPIO multiplexer 5
This bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
1x: Reserved</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_F1</name>
                    <description>PA3</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_F1</name>
                    <description>PA4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_F1</name>
                    <description>PA5</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_STM32C011X___GPIO_ASSIGNED_TO_WLCSP12_PIN_F1</name>
                    <description>PA6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_J3</name>
                    <description>PA3</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_STM32C031X___GPIO_ASSIGNED_TO_WLCSP14_PIN_J3</name>
                    <description>PA4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE0</name>
            <displayName>SYSCFG_ITLINE0</displayName>
            <description>SYSCFG interrupt line 0 status register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WWDG</name>
                <description>Window watchdog interrupt pending flag</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE2</name>
            <displayName>SYSCFG_ITLINE2</displayName>
            <description>SYSCFG interrupt line 2 status register </description>
            <addressOffset>0x88</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RTC</name>
                <description>RTC interrupt request pending (EXTI line 19)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE3</name>
            <displayName>SYSCFG_ITLINE3</displayName>
            <description>SYSCFG interrupt line 3 status register </description>
            <addressOffset>0x8c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLASH_ITF</name>
                <description>Flash interface interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE4</name>
            <displayName>SYSCFG_ITLINE4</displayName>
            <description>SYSCFG interrupt line 4 status register </description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RCC</name>
                <description>Reset and clock control interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE5</name>
            <displayName>SYSCFG_ITLINE5</displayName>
            <description>SYSCFG interrupt line 5 status register </description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTI line 0 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI1</name>
                <description>EXTI line 1 interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE6</name>
            <displayName>SYSCFG_ITLINE6</displayName>
            <description>SYSCFG interrupt line 6 status register </description>
            <addressOffset>0x98</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI2</name>
                <description>EXTI line 2 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI3</name>
                <description>EXTI line 3 interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE7</name>
            <displayName>SYSCFG_ITLINE7</displayName>
            <description>SYSCFG interrupt line 7 status register </description>
            <addressOffset>0x9c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI4</name>
                <description>EXTI line 4 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI5</name>
                <description>EXTI line 5 interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI6</name>
                <description>EXTI line 6 interrupt request pending</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI7</name>
                <description>EXTI line 7 interrupt request pending</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI8</name>
                <description>EXTI line 8 interrupt request pending</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI9</name>
                <description>EXTI line 9 interrupt request pending</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI10</name>
                <description>EXTI line 10 interrupt request pending</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI11</name>
                <description>EXTI line 11 interrupt request pending</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI12</name>
                <description>EXTI line 12 interrupt request pending</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI13</name>
                <description>EXTI line 13 interrupt request pending</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI14</name>
                <description>EXTI line 14 interrupt request pending</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTI15</name>
                <description>EXTI line 15 interrupt request pending</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE9</name>
            <displayName>SYSCFG_ITLINE9</displayName>
            <description>SYSCFG interrupt line 9 status register </description>
            <addressOffset>0xa4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA1_CH1</name>
                <description>DMA1 channel 1interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE10</name>
            <displayName>SYSCFG_ITLINE10</displayName>
            <description>SYSCFG interrupt line 10 status register </description>
            <addressOffset>0xa8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA1_CH2</name>
                <description>DMA1 channel 2 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DMA1_CH3</name>
                <description>DMA1 channel 3 interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE11</name>
            <displayName>SYSCFG_ITLINE11</displayName>
            <description>SYSCFG interrupt line 11 status register </description>
            <addressOffset>0xac</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAMUX</name>
                <description>DMAMUX interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE12</name>
            <displayName>SYSCFG_ITLINE12</displayName>
            <description>SYSCFG interrupt line 12 status register </description>
            <addressOffset>0xb0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC</name>
                <description>ADC interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE13</name>
            <displayName>SYSCFG_ITLINE13</displayName>
            <description>SYSCFG interrupt line 13 status register </description>
            <addressOffset>0xb4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1_CCU</name>
                <description>Timer 1 commutation interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIM1_TRG</name>
                <description>Timer 1 trigger interrupt request pending</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIM1_UPD</name>
                <description>Timer 1 update interrupt request pending</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIM1_BRK</name>
                <description>Timer 1 break interrupt request pending</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE14</name>
            <displayName>SYSCFG_ITLINE14</displayName>
            <description>SYSCFG interrupt line 14 status register </description>
            <addressOffset>0xb8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1_CC</name>
                <description>Timer 1 capture compare interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE16</name>
            <displayName>SYSCFG_ITLINE16</displayName>
            <description>SYSCFG interrupt line 16 status register </description>
            <addressOffset>0xc0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM3</name>
                <description>Timer 3 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE19</name>
            <displayName>SYSCFG_ITLINE19</displayName>
            <description>SYSCFG interrupt line 19 status register </description>
            <addressOffset>0xcc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM14</name>
                <description>Timer 14 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE21</name>
            <displayName>SYSCFG_ITLINE21</displayName>
            <description>SYSCFG interrupt line 21 status register </description>
            <addressOffset>0xd4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM16</name>
                <description>Timer 16 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE22</name>
            <displayName>SYSCFG_ITLINE22</displayName>
            <description>SYSCFG interrupt line 22 status register </description>
            <addressOffset>0xd8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM17</name>
                <description>Timer 17 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE23</name>
            <displayName>SYSCFG_ITLINE23</displayName>
            <description>SYSCFG interrupt line 23 status register </description>
            <addressOffset>0xdc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>I2C1</name>
                <description>I2C1 interrupt request pending, combined with EXTI line 23</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE25</name>
            <displayName>SYSCFG_ITLINE25</displayName>
            <description>SYSCFG interrupt line 25 status register </description>
            <addressOffset>0xe4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPI1</name>
                <description>SPI1 interrupt request pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE27</name>
            <displayName>SYSCFG_ITLINE27</displayName>
            <description>SYSCFG interrupt line 27 status register </description>
            <addressOffset>0xec</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>USART1</name>
                <description>USART1 interrupt request pending, combined with EXTI line 25</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYSCFG_ITLINE28</name>
            <displayName>SYSCFG_ITLINE28</displayName>
            <description>SYSCFG interrupt line 28 status register </description>
            <addressOffset>0xf0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>USART2</name>
                <description>USART2 interrupt request pending (EXTI line 26)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>TIM1</name>
        <description>Advanced-control timer</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40012C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM1_BRK_UP_TRG_COM</name>
          <description>TIM1 break, update, trigger and commutation interrupts</description>
          <value>13</value>
        </interrupt>
		<interrupt>
          <name>TIM1_CC</name>
          <description>TIM1 Capture Compare interrupt</description>
          <value>14</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM1_CR1</name>
            <displayName>TIM1_CR1</displayName>
            <description>TIM1 control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter used as upcounter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter used as downcounter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMS</name>
                <description>Center-aligned mode selection
Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx):
Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS=tCK_INT</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS=2*tCK_INT</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS=4*tCK_INT</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved, do not program this value</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CR2</name>
            <displayName>TIM1_CR2</displayName>
            <description>TIM1 control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCPC</name>
                <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCxE, CCxNE and OCxM bits are not preloaded</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCUS</name>
                <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS</name>
                <description>Master mode selection
These bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - OC1REFC signal is used as trigger output (TRGO)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - OC2REFC signal is used as trigger output (TRGO)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - OC3REFC signal is used as trigger output (TRGO)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - OC4REFC signal is used as trigger output (TRGO)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI1S</name>
                <description>TI1 selection</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The TIMx_CH1 pin is connected to TI1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1</name>
                <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1=0 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1=1 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1N</name>
                <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N=0 after a dead-time when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N=1 after a dead-time when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS2</name>
                <description>Output Idle state 2 (OC2 output)
Refer to OIS1 bit</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS2N</name>
                <description>Output Idle state 2 (OC2N output)
Refer to OIS1N bit</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS3</name>
                <description>Output Idle state 3 (OC3 output)
Refer to OIS1 bit</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS3N</name>
                <description>Output Idle state 3 (OC3N output)
Refer to OIS1N bit</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS4</name>
                <description>Output Idle state 4 (OC4 output)
Refer to OIS1 bit</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS5</name>
                <description>Output Idle state 5 (OC5 output)
Refer to OIS1 bit</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OIS6</name>
                <description>Output Idle state 6 (OC6 output)
Refer to OIS1 bit</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MMS2</name>
                <description>Master mode selection 2
These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - OC1REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - OC2REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - OC3REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - OC4REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Compare - OC5REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Compare - OC6REFC signal is used as trigger output (TRGO2)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_SMCR</name>
            <displayName>TIM1_SMCR</displayName>
            <description>TIM1 slave mode control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMS1</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.Codes above 1000: Reserved.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OCCS</name>
                <description>OCREF clear selection
This bit is used to select the OCREF clear source.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OCREF_CLR_INT is not connected (reserved configuration)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OCREF_CLR_INT is connected to ETRF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS1</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal Trigger 0 (ITR0) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal Trigger 1 (ITR1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal Trigger 2 (ITR2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal Trigger 3 (ITR3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TI1 Edge Detector (TI1F_ED)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered Timer Input 1 (TI1FP1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered Timer Input 2 (TI2FP2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Trigger input (ETRF)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSM</name>
                <description>Master/slave mode</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETF</name>
                <description>External trigger filter
This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETPS</name>
                <description>External trigger prescaler
External trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Prescaler OFF</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ETRP frequency divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>ETRP frequency divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>ETRP frequency divided by 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ECE</name>
                <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>External clock mode 2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETP</name>
                <description>External trigger polarity
This bit selects whether ETR or ETR is used for trigger operations</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ETR is non-inverted, active at high level or rising edge.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ETR is inverted, active at low level or falling edge.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMS2</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.Codes above 1000: Reserved.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS2</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal Trigger 0 (ITR0) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal Trigger 1 (ITR1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal Trigger 2 (ITR2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal Trigger 3 (ITR3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TI1 Edge Detector (TI1F_ED)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered Timer Input 1 (TI1FP1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered Timer Input 2 (TI2FP2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Trigger input (ETRF)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_DIER</name>
            <displayName>TIM1_DIER</displayName>
            <description>TIM1 DMA/interrupt enable register </description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/Compare 2 interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3IE</name>
                <description>Capture/Compare 3 interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4IE</name>
                <description>Capture/Compare 4 interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMIE</name>
                <description>COM interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COM interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIE</name>
                <description>Trigger interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIE</name>
                <description>Break interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2DE</name>
                <description>Capture/Compare 2 DMA request enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3DE</name>
                <description>Capture/Compare 3 DMA request enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4DE</name>
                <description>Capture/Compare 4 DMA request enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMDE</name>
                <description>COM DMA request enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COM DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TDE</name>
                <description>Trigger DMA request enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_SR</name>
            <displayName>TIM1_SR</displayName>
            <description>TIM1 status register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3IF</name>
                <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4IF</name>
                <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMIF</name>
                <description>COM interrupt flag
This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No COM event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIF</name>
                <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIF</name>
                <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>B2IF</name>
                <description>Break 2 interrupt flag
This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OF</name>
                <description>Capture/Compare 2 overcapture flag
Refer to CC1OF description</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3OF</name>
                <description>Capture/Compare 3 overcapture flag
Refer to CC1OF description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4OF</name>
                <description>Capture/Compare 4 overcapture flag
Refer to CC1OF description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SBIF</name>
                <description>System Break interrupt flag
This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.
This flag must be reset to re-start PWM operation.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC5IF</name>
                <description>Compare 5 interrupt flag
Refer to CC1IF description (Note: Channel 5 can only be configured as output)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC6IF</name>
                <description>Compare 6 interrupt flag
Refer to CC1IF description (Note: Channel 6 can only be configured as output)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_EGR</name>
            <displayName>TIM1_EGR</displayName>
            <description>TIM1 event generation register </description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2G</name>
                <description>Capture/Compare 2 generation
Refer to CC1G description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC3G</name>
                <description>Capture/Compare 3 generation
Refer to CC1G description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC4G</name>
                <description>Capture/Compare 4 generation
Refer to CC1G description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>COMG</name>
                <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware
Note: This bit acts only on channels having a complementary output.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TG</name>
                <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BG</name>
                <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>B2G</name>
                <description>Break 2 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCMR1_input</name>
            <displayName>TIM1_CCMR1_input</displayName>
            <description>TIM1 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2PSC</name>
                <description>Input capture 2 prescaler
Refer to IC1PSC[1:0] description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC2F</name>
                <description>Input capture 2 filter
Refer to IC1F[3:0] description.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM1_CCMR1_output</name>
            <displayName>TIM1_CCMR1_output</displayName>
            <description>TIM1 capture/compare mode register 1 [alternate]</description>
			<alternateRegister>TIM1_CCMR1_input</alternateRegister>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as TIMx_CNT&gt;TIMx_CCR1 else active (OC1REF=’1’).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retrigerrable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retrigerrable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1CE</name>
                <description>Output Compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1Ref is not affected by the ocref_clr_int signal</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1Ref is cleared as soon as a High level is detected on ocref_clr_int signal (OCREF_CLR input or ETRF input)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2FE</name>
                <description>Output Compare 2 fast enable
Refer to OC1FE description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output Compare 2 preload enable
Refer to OC1PE description.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M1</name>
                <description>Output Compare 2 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2CE</name>
                <description>Output Compare 2 clear enable
Refer to OC1CE description.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as TIMx_CNT&gt;TIMx_CCR1 else active (OC1REF=’1’).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retrigerrable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retrigerrable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>              
              <field>
                <name>OC2M2</name>
                <description>Output Compare 2 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>TIM1_CCMR2_input</name>
            <displayName>TIM1_CCMR2_input</displayName>
            <description>TIM1 capture/compare mode register 2 [alternate]</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC3S</name>
                <description>Capture/compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC3PSC</name>
                <description>Input capture 3 prescaler
Refer to IC1PSC[1:0] description.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC3F</name>
                <description>Input capture 3 filter
Refer to IC1F[3:0] description.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC4PSC</name>
                <description>Input capture 4 prescaler
Refer to IC1PSC[1:0] description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC4F</name>
                <description>Input capture 4 filter
Refer to IC1F[3:0] description.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM1_CCMR2_output</name>
            <displayName>TIM1_CCMR2_output</displayName>
            <description>TIM1 capture/compare mode register 2 [alternate]</description>
			<alternateRegister>TIM1_CCMR2_input</alternateRegister>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
             <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC3FE</name>
                <description>Output compare 3 fast enable
Refer to OC1FE description.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3PE</name>
                <description>Output compare 3 preload enable
Refer to OC1PE description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M1</name>
                <description>Output compare 3 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3CE</name>
                <description>Output compare 3 clear enable
Refer to OC1CE description.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC4FE</name>
                <description>Output compare 4 fast enable
Refer to OC1FE description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4PE</name>
                <description>Output compare 4 preload enable
Refer to OC1PE description.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M1</name>
                <description>Output compare 4 mode
Refer to OC3M[3:0] description.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4CE</name>
                <description>Output compare 4 clear enable
Refer to OC1CE description.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M2</name>
                <description>Output compare 3 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>           
              <field>
                <name>OC4M2</name>
                <description>Output compare 4 mode
Refer to OC3M[3:0] description.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
          <register>
            <name>TIM1_CCER</name>
            <displayName>TIM1_CCER</displayName>
            <description>TIM1 capture/compare enable register	</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.
Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active (see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	The configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NE</name>
                <description>Capture/Compare 1 complementary output enable
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=”00” (channel configured as output).
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N active high.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N active low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2E</name>
                <description>Capture/Compare 2 output enable
Refer to CC1E description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2P</name>
                <description>Capture/Compare 2 output polarity
Refer to CC1P description</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2NE</name>
                <description>Capture/Compare 2 complementary output enable
Refer to CC1NE description</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2NP</name>
                <description>Capture/Compare 2 complementary output polarity
Refer to CC1NP description</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3E</name>
                <description>Capture/Compare 3 output enable
Refer to CC1E description</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3P</name>
                <description>Capture/Compare 3 output polarity
Refer to CC1P description</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3NE</name>
                <description>Capture/Compare 3 complementary output enable
Refer to CC1NE description</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3NP</name>
                <description>Capture/Compare 3 complementary output polarity
Refer to CC1NP description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4E</name>
                <description>Capture/Compare 4 output enable
Refer to CC1E description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4P</name>
                <description>Capture/Compare 4 output polarity
Refer to CC1P description</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4NP</name>
                <description>Capture/Compare 4 complementary output polarity
Refer to CC1NP description</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC5E</name>
                <description>Capture/Compare 5 output enable
Refer to CC1E description</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC5P</name>
                <description>Capture/Compare 5 output polarity
Refer to CC1P description</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC6E</name>
                <description>Capture/Compare 6 output enable
Refer to CC1E description</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC6P</name>
                <description>Capture/Compare 6 output polarity
Refer to CC1P description</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CNT</name>
            <displayName>TIM1_CNT</displayName>
            <description>TIM1 counter </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_PSC</name>
            <displayName>TIM1_PSC</displayName>
            <description>TIM1 prescaler </description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_ARR</name>
            <displayName>TIM1_ARR</displayName>
            <description>TIM1 auto-reload register </description>
            <addressOffset>0x2c</addressOffset>
            <size>16</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_RCR</name>
            <displayName>TIM1_RCR</displayName>
            <description>TIM1 repetition counter register </description>
            <addressOffset>0x30</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>REP</name>
                <description>Repetition counter value
These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event.
It means in PWM mode (REP+1) corresponds to:
the number of PWM periods in edge-aligned mode
the number of half PWM period in center-aligned mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR1</name>
            <displayName>TIM1_CCR1</displayName>
            <description>TIM1 capture/compare register 1 </description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/Compare 1 value
If channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR2</name>
            <displayName>TIM1_CCR2</displayName>
            <description>TIM1 capture/compare register 2 </description>
            <addressOffset>0x38</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR2</name>
                <description>Capture/Compare 2 value
If channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC2 output.
If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR3</name>
            <displayName>TIM1_CCR3</displayName>
            <description>TIM1 capture/compare register 3 </description>
            <addressOffset>0x3c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR3</name>
                <description>Capture/Compare value
If channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.
If channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR4</name>
            <displayName>TIM1_CCR4</displayName>
            <description>TIM1 capture/compare register 4 </description>
            <addressOffset>0x40</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR4</name>
                <description>Capture/Compare value
If channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.
If channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_BDTR</name>
            <displayName>TIM1_BDTR</displayName>
            <description>TIM1 break and dead-time register	</description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTG</name>
                <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5] = 0xx =&gt; DT = DTG[7:0] x tDTG with tDTG = tDTS.
DTG[7:5] = 10x =&gt; DT = (64 + DTG[5:0]) x tDTG with tDTG = 2 x tDTS.
DTG[7:5] = 110 =&gt; DT = (32 + DTG[4:0]) x tDTG with tDTG = 8 x tDTS.
DTG[7:5] = 111 =&gt; DT = (32 + DTG[4:0]) x tDTG with tDTG = 16 x tDTS.
Example if tDTS = 125 ns (8 MHz), dead-time possible values are:
0 to 15875 ns by 125 ns steps,
16 μs to 31750 ns  by 250 ns steps,
32 μs to 63 μs by 1 μs steps,
64 μs to 126 μs by 2 μs steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LOCK OFF - No bit is write protected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits in TIMx_BDTR register can no longer be written.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSI</name>
                <description>Off-state selection for Idle mode
This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSR</name>
                <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKE</name>
                <description>Break enable
This bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per ).
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break function disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break function enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKP</name>
                <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AOE</name>
                <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>MOE can be set only by software</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MOE</name>
                <description>Main output enable
This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>In response to a break 2 event. OC and OCN outputs are disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKF</name>
                <description>Break filter
This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, BRK acts asynchronously</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2F</name>
                <description>Break 2 filter
This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, BRK2 acts asynchronously</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2E</name>
                <description>Break 2 enable
Note: The BRK2 must only be used with OSSR = OSSI = 1.
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK2 enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2P</name>
                <description>Break 2 polarity
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK2 is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK2 is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKDSRM</name>
                <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is armed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is disarmed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2DSRM</name>
                <description>Break2 Disarm
Refer to BKDSRM description</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BKBID</name>
                <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK in input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK in bidirectional mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2BID</name>
                <description>Break2 bidirectional
Refer to BKBID description</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_DCR</name>
            <displayName>TIM1_DCR</displayName>
            <description>TIM1 DMA control register </description>
            <addressOffset>0x48</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...
Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIMx_CR1.
If DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:
(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL
In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA
According to the configuration of the DMA Data Size, several cases may occur:
If the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers.
If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>18 transfers</description>
                    <value>0x11</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_DMAR</name>
            <displayName>TIM1_DMAR</displayName>
            <description>TIM1 DMA address for full transfer	</description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCMR3</name>
            <displayName>TIM1_CCMR3</displayName>
            <description>TIM1 capture/compare mode register 3	</description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OC5FE</name>
                <description>Output compare 5 fast enable
Refer to OC1FE description.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC5PE</name>
                <description>Output compare 5 preload enable
Refer to OC1PE description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC5M1</name>
                <description>Output compare 5 mode
Refer to OC1M description.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC5CE</name>
                <description>Output compare 5 clear enable
Refer to OC1CE description.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC6FE</name>
                <description>Output compare 6 fast enable
Refer to OC1FE description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC6PE</name>
                <description>Output compare 6 preload enable
Refer to OC1PE description.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC6M1</name>
                <description>Output compare 6 mode
Refer to OC1M description.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC6CE</name>
                <description>Output compare 6 clear enable
Refer to OC1CE description.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC5M2</name>
                <description>Output compare 5 mode
Refer to OC1M description.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC6M2</name>
                <description>Output compare 6 mode
Refer to OC1M description.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR5</name>
            <displayName>TIM1_CCR5</displayName>
            <description>TIM1 capture/compare register 5 </description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR5</name>
                <description>Capture/Compare 5 value
CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>GC5C1</name>
                <description>Group Channel 5 and Channel 1
Distortion on Channel 1 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect of OC5REF on OC1REFC5</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1REFC is the logical AND of OC1REFC and OC5REF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GC5C2</name>
                <description>Group Channel 5 and Channel 2
Distortion on Channel 2 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect of OC5REF on OC2REFC</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC2REFC is the logical AND of OC2REFC and OC5REF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GC5C3</name>
                <description>Group Channel 5 and Channel 3
Distortion on Channel 3 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect of OC5REF on OC3REFC</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC3REFC is the logical AND of OC3REFC and OC5REF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_CCR6</name>
            <displayName>TIM1_CCR6</displayName>
            <description>TIM1 capture/compare register 6 </description>
            <addressOffset>0x5c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR6</name>
                <description>Capture/Compare 6 value
CCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC6 output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_AF1</name>
            <displayName>TIM1_AF1</displayName>
            <description>TIM1 alternate function option register 1 </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BKINE</name>
                <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer’s BRK input. BKIN input is ‘ORed’ with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKINP</name>
                <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETRSEL</name>
                <description>ETR source selection
These bits select the ETR input source.
Others: Reserved
Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ETR legacy mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>ADC1 AWD1</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>ADC1 AWD2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>ADC1 AWD3</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_AF2</name>
            <displayName>TIM1_AF2</displayName>
            <description>TIM1 Alternate function register 2 </description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BK2INE</name>
                <description>BRK2 BKIN input enable
This bit enables the BKIN2 alternate function input for the timer’s BRK2 input. BKIN2 input is ‘ORed’ with the other BRK2 sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN2 input disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN2 input enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BK2INP</name>
                <description>BRK2 BKIN2 input polarity
This bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM1_TISEL</name>
            <displayName>TIM1_TISEL</displayName>
            <description>TIM1 timer input selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1_CH1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI2SEL</name>
                <description>selects TI2[0] to TI2[15] input
Others: Reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1_CH2 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI3SEL</name>
                <description>selects TI3[0] to TI3[15] input
Others: Reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1_CH3 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI4SEL</name>
                <description>selects TI4[0] to TI4[15] input
Others: Reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1_CH4 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>TIM3</name>
        <description>General-purpose timer</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40000400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM3</name>
          <description>TIM3 gloabal interrupt</description>
          <value>16</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM3_CR1</name>
            <displayName>TIM3_CR1</displayName>
            <description>TIM3 control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter used as upcounter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter used as downcounter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMS</name>
                <description>Center-aligned mode selection
Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = tCK_INT</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 � tCK_INT</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 � tCK_INT</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CR2</name>
            <displayName>TIM3_CR2</displayName>
            <description>TIM3 control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS</name>
                <description>Master mode selection
These bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - OC1REFC signal is used as trigger output (TRGO)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - OC2REFC signal is used as trigger output (TRGO)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - OC3REFC signal is used as trigger output (TRGO)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - OC4REFC signal is used as trigger output (TRGO)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI1S</name>
                <description>TI1 selection</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The TIMx_CH1 pin is connected to TI1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_SMCR</name>
            <displayName>TIM3_SMCR</displayName>
            <description>TIM3 slave mode control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMS1</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
reinitializes the counter, generates an update of the registers and starts the counter.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OCCS</name>
                <description>OCREF clear selection
This bit is used to select the OCREF clear source</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OCREF_CLR_INT is unconnected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OCREF_CLR_INT is connected to ETRF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS1</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal Trigger 0 (ITR0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal Trigger 1 (ITR1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal Trigger 2 (ITR2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal Trigger 3 (ITR3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TI1 Edge Detector (TI1F_ED)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered Timer Input 1 (TI1FP1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered Timer Input 2 (TI2FP2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Trigger input (ETRF)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal Trigger 4 (ITR4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal Trigger 5 (ITR5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal Trigger 6 (ITR6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal Trigger 7 (ITR7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal Trigger 8 (ITR8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSM</name>
                <description>Master/Slave mode</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETF</name>
                <description>External trigger filter
This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETPS</name>
                <description>External trigger prescaler
External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Prescaler OFF</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ETRP frequency divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>ETRP frequency divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>ETRP frequency divided by 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ECE</name>
                <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>External clock mode 2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETP</name>
                <description>External trigger polarity
This bit selects whether ETR or ETR is used for trigger operations</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ETR is non-inverted, active at high level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ETR is inverted, active at low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMS2</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
reinitializes the counter, generates an update of the registers and starts the counter.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS2</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal Trigger 0 (ITR0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal Trigger 1 (ITR1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal Trigger 2 (ITR2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal Trigger 3 (ITR3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TI1 Edge Detector (TI1F_ED)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered Timer Input 1 (TI1FP1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered Timer Input 2 (TI2FP2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Trigger input (ETRF)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal Trigger 4 (ITR4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal Trigger 5 (ITR5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal Trigger 6 (ITR6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal Trigger 7 (ITR7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal Trigger 8 (ITR8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DIER</name>
            <displayName>TIM3_DIER</displayName>
            <description>TIM3 DMA/Interrupt enable register </description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/Compare 2 interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3IE</name>
                <description>Capture/Compare 3 interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4IE</name>
                <description>Capture/Compare 4 interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIE</name>
                <description>Trigger interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2DE</name>
                <description>Capture/Compare 2 DMA request enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3DE</name>
                <description>Capture/Compare 3 DMA request enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4DE</name>
                <description>Capture/Compare 4 DMA request enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TDE</name>
                <description>Trigger DMA request enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_SR</name>
            <displayName>TIM3_SR</displayName>
            <description>TIM3 status register </description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow and if UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3IF</name>
                <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4IF</name>
                <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIF</name>
                <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OF</name>
                <description>Capture/compare 2 overcapture flag
refer to CC1OF description</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3OF</name>
                <description>Capture/Compare 3 overcapture flag
refer to CC1OF description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4OF</name>
                <description>Capture/Compare 4 overcapture flag
refer to CC1OF description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_EGR</name>
            <displayName>TIM3_EGR</displayName>
            <description>TIM3 event generation register </description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2G</name>
                <description>Capture/compare 2 generation
Refer to CC1G description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC3G</name>
                <description>Capture/compare 3 generation
Refer to CC1G description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC4G</name>
                <description>Capture/compare 4 generation
Refer to CC1G description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TG</name>
                <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCMR1_input</name>
            <displayName>TIM3_CCMR1_input</displayName>
            <description>TIM3 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI2.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI1.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2PSC</name>
                <description>Input capture 2 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC2F</name>
                <description>Input capture 2 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM3_CCMR1_output</name>
            <displayName>TIM3_CCMR1_output</displayName>
            <description>TIM3 capture/compare mode register 1 [alternate]</description>
			<alternateRegister>TIM3_CCMR1_input</alternateRegister>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
             <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI2.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable
Note: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (OC1REF=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1CE</name>
                <description>Output compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1Ref is not affected by the ETRF input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1Ref is cleared as soon as a High level is detected on ETRF input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TI1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2FE</name>
                <description>Output compare 2 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output compare 2 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M1</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2CE</name>
                <description>Output compare 2 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (OC1REF=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2M2</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>TIM3_CCMR2_input</name>
            <displayName>TIM3_CCMR2_input</displayName>
            <description>TIM3 capture/compare mode register 2 [alternate]</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC3PSC</name>
                <description>Input capture 3 prescaler</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC3F</name>
                <description>Input capture 3 filter</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC4PSC</name>
                <description>Input capture 4 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC4F</name>
                <description>Input capture 4 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM3_CCMR2_output</name>
            <displayName>TIM3_CCMR2_output</displayName>
            <description>TIM3 capture/compare mode register 2 [alternate]</description>
			<alternateRegister>TIM3_CCMR2_input</alternateRegister>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TI4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC3FE</name>
                <description>Output compare 3 fast enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3PE</name>
                <description>Output compare 3 preload enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M1</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3CE</name>
                <description>Output compare 3 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TI3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC4FE</name>
                <description>Output compare 4 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4PE</name>
                <description>Output compare 4 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M1</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4CE</name>
                <description>Output compare 4 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M2</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M2</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>TIM3_CCER</name>
            <displayName>TIM3_CCER</displayName>
            <description>TIM3 capture/compare enable register	</description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	This configuration is reserved, it must not be used.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared in this case.
CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2E</name>
                <description>Capture/Compare 2 output enable.
Refer to CC1E description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2P</name>
                <description>Capture/Compare 2 output Polarity.
refer to CC1P description</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2NP</name>
                <description>Capture/Compare 2 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3E</name>
                <description>Capture/Compare 3 output enable.
Refer to CC1E description</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3P</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1P description</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3NP</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4E</name>
                <description>Capture/Compare 4 output enable.
refer to CC1E description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4P</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1P description</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4NP</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CNT</name>
            <displayName>TIM3_CNT</displayName>
            <description>TIM3 counter [alternate] </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>TIM3_CNT_alternate</name>
            <displayName>TIM3_CNT_alternate</displayName>
            <description>TIM3 counter [alternate] </description>
			<alternateRegister>TIM3_CNT</alternateRegister>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>TIM3_PSC</name>
            <displayName>TIM3_PSC</displayName>
            <description>TIM3 prescaler </description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_ARR</name>
            <displayName>TIM3_ARR</displayName>
            <description>TIM3 auto-reload register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR1</name>
            <displayName>TIM3_CCR1</displayName>
            <description>TIM3 capture/compare register 1 </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/Compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR2</name>
            <displayName>TIM3_CCR2</displayName>
            <description>TIM3 capture/compare register 2 </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR2</name>
                <description>Capture/Compare 2 value
If channel CC2 is configured as output:
CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output.
If channel CC2 is configured as input:
CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR3</name>
            <displayName>TIM3_CCR3</displayName>
            <description>TIM3 capture/compare register 3 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR3</name>
                <description>Capture/Compare value
If channel CC3 is configured as output:
CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.
If channel CC3is configured as input:
CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR4</name>
            <displayName>TIM3_CCR4</displayName>
            <description>TIM3 capture/compare register 4 </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR4</name>
                <description>Capture/Compare value
if CC4 channel is configured as output (CC4S bits):
CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.
if CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register):
CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DCR</name>
            <displayName>TIM3_DCR</displayName>
            <description>TIM3 DMA control register </description>
            <addressOffset>0x48</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...
Example: Let us consider the following transfer: DBL = 7 transfers &amp; DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>18 transfers.</description>
                    <value>0x11</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DMAR</name>
            <displayName>TIM3_DMAR</displayName>
            <description>TIM3 DMA address for full transfer </description>
            <addressOffset>0x4c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address
(TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_AF1</name>
            <displayName>TIM3_AF1</displayName>
            <description>TIM3 alternate function option register 1 </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ETRSEL</name>
                <description>ETR source selection
These bits select the ETR input source.
Others: Reserved</description>
                <bitOffset>14</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ETR legacy mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_TISEL</name>
            <displayName>TIM3_TISEL</displayName>
            <description>TIM3 timer input selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>TI1[0] to TI1[15] input selection
These bits select the TI1[0] to TI1[15] input source.
Others: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM3_CH1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI2SEL</name>
                <description>TI2[0] to TI2[15] input selection
These bits select the TI2[0] to TI2[15] input source.
Others: Reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM3_CH2 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI3SEL</name>
                <description>TI3[0] to TI3[15] input selection
These bits select the TI3[0] to TI3[15] input source.
Others: Reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM3_CH3 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>TIM14</name>
        <description>General-purpose timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40002000</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM14</name>
          <description>TIM14 gloabal interrupt</description>
          <value>19</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM14_CR1</name>
            <displayName>TIM14_CR1</displayName>
            <description>TIM14 control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by
software. However trigger mode can set the CEN bit automatically by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable update interrupt (UEV) event generation.
Counter overflow
Setting the UG bit.
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. An UEV is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. No UEV is generated, shadow registers keep their value (ARR, PSC, CCRx). The counter and the prescaler are reinitialized if the UG bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the update interrupt (UEV) sources.
Counter overflow
Setting the UG bit</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an UEV if enabled: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow generates an UEV if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped on the update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting on the next update event (clearing the CEN bit).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = tCK_INT</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 � tCK_INT</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 � tCK_INT</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_DIER</name>
            <displayName>TIM14_DIER</displayName>
            <description>TIM14 Interrupt enable register </description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_SR</name>
            <displayName>TIM14_SR</displayName>
            <description>TIM14 status register </description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow and if UDIS=’0’ in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=’0’ and UDIS=’0’ in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_EGR</name>
            <displayName>TIM14_EGR</displayName>
            <description>TIM14 event generation register </description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_CCMR1_input</name>
            <displayName>TIM14_CCMR1_input</displayName>
            <description>TIM14 capture/compare mode register 1 [alternate] </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM14_CCMR1_output</name>
            <displayName>TIM14_CCMR1_output</displayName>
            <description>TIM14 capture/compare mode register 1 [alternate] </description>
			<alternateRegister>TIM14_CCMR1_input</alternateRegister>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. OC is then set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable
Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output compare 1 mode (refer to bit 16 for OC1M[3])
These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.
Others: Reserved
Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT = TIMx_CCR1. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT &lt; TIMx_CCR1 else inactive.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT &lt; TIMx_CCR1 else active</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>             
              <field>
                <name>OC1M2</name>
                <description>Output compare 1 mode (refer to bit 16 for OC1M[3])
These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.
Others: Reserved
Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT = TIMx_CCR1. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT &lt; TIMx_CCR1 else inactive.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT &lt; TIMx_CCR1 else active</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>TIM14_CCER</name>
            <displayName>TIM14_CCER</displayName>
            <description>TIM14 capture/compare enable register </description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	This configuration is reserved, it must not be used.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 complementary output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared.
CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_CNT</name>
            <displayName>TIM14_CNT</displayName>
            <description>TIM14 counter </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF Copy
This bit is a read-only copy of the UIF bit in the TIMx_ISR register.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_PSC</name>
            <displayName>TIM14_PSC</displayName>
            <description>TIM14 prescaler </description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event.
(including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_ARR</name>
            <displayName>TIM14_ARR</displayName>
            <description>TIM14 auto-reload register </description>
            <addressOffset>0x2c</addressOffset>
            <size>16</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_CCR1</name>
            <displayName>TIM14_CCR1</displayName>
            <description>TIM14 capture/compare register 1 </description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/Compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (IC1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM14_TISEL</name>
            <displayName>TIM14_TISEL</displayName>
            <description>TIM14 timer input selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM14_CH1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTC CLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE/32</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>MCO</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>MCO2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>TIM16</name>
        <description>General-purpose timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40014400</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM16</name>
          <description>TIM16 global interrupt</description>
          <value>21</value>
        </interrupt>		
        <registers>
          <register>
            <name>TIM16_CR1</name>
            <displayName>TIM16_CR1</displayName>
            <description>TIM16 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = tCK_INT</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 * tCK_INT</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 * tCK_INT</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved, do not program this value</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_CR2</name>
            <displayName>TIM16_CR2</displayName>
            <description>TIM16 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCPC</name>
                <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCxE, CCxNE and OCxM bits are not preloaded</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCUS</name>
                <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1</name>
                <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1=0 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1=1 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1N</name>
                <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N=0 after a dead-time when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N=1 after a dead-time when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_DIER</name>
            <displayName>TIM16_DIER</displayName>
            <description>TIM16 DMA/interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMIE</name>
                <description>COM interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COM interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIE</name>
                <description>Break interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_SR</name>
            <displayName>TIM16_SR</displayName>
            <description>TIM16 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMIF</name>
                <description>COM interrupt flag
This flag is set by hardware on a COM event (once the capture/compare control bits –CCxE, CCxNE, OCxM– have been updated). It is cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No COM event occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIF</name>
                <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break event occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active level has been detected on the break input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_EGR</name>
            <displayName>TIM16_EGR</displayName>
            <description>TIM16 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMG</name>
                <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware.
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BG</name>
                <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_CCMR1_input</name>
            <displayName>TIM16_CCMR1_input</displayName>
            <description>TIM16 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM16_CCMR1_output</name>
            <displayName>TIM16_CCMR1_output</displayName>
            <description>TIM16 capture/compare mode register 1 [alternate]</description>
			<alternateRegister>TIM16_CCMR1_input</alternateRegister>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
          <register>
            <name>TIM16_CCER</name>
            <displayName>TIM16_CCER</displayName>
            <description>TIM16 capture/compare enable register</description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active (see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NE</name>
                <description>Capture/Compare 1 complementary output enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer
to the description of CC1P.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=”00” (the channel is configured in output).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N active high</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N active low</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_CNT</name>
            <displayName>TIM16_CNT</displayName>
            <description>TIM16 counter</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_PSC</name>
            <displayName>TIM16_PSC</displayName>
            <description>TIM16 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_ARR</name>
            <displayName>TIM16_ARR</displayName>
            <description>TIM16 auto-reload register</description>
            <addressOffset>0x2c</addressOffset>
            <size>16</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_RCR</name>
            <displayName>TIM16_RCR</displayName>
            <description>TIM16 repetition counter register</description>
            <addressOffset>0x30</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>REP</name>
                <description>Repetition counter value
These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event.
It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_CCR1</name>
            <displayName>TIM16_CCR1</displayName>
            <description>TIM16 capture/compare register 1</description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/Compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1 is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (IC1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_BDTR</name>
            <displayName>TIM16_BDTR</displayName>
            <description>TIM16 break and dead-time register</description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTG</name>
                <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5] = 0xx =&gt; DT = DTG[7:0] x tdtg with tdtg = tDTS
DTG[7:5] = 10x =&gt; DT = (64 + DTG[5:0]) x tdtg with tdtg = 2 x tDTS
DTG[7:5] = 110 =&gt; DT = (32 + DTG[4:0]) x tdtg with tdtg = 8 x tDTS
DTG[7:5] = 111 =&gt; DT = (32 + DTG[4:0]) x tdtg with tdtg = 16 x tDTS
Example if tDTS = 125 ns (8 MHz), dead-time possible values are:
0 to 15875 ns by 125 ns steps,
16 �s to 31750 ns by 250 ns steps,
32 �s to 63 �s by 1 �s steps,
64 �s to 126 �s by 2 �s steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LOCK OFF - No bit is write protected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSI</name>
                <description>Off-state selection for Idle mode
This bit is used when MOE=0 on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSR</name>
                <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKE</name>
                <description>Break enable
1; Break inputs (BRK and CCS clock failure event) enabled
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break inputs (BRK and CCS clock failure event) disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKP</name>
                <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AOE</name>
                <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>MOE can be set only by software</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MOE can be set by software or automatically at the next update event (if the break input is not be active)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MOE</name>
                <description>Main output enable
This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details (</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKF</name>
                <description>Break filter
This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:
This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, BRK acts asynchronously</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKDSRM</name>
                <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is armed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is disarmed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKBID</name>
                <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK in input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK in bidirectional mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_DCR</name>
            <displayName>TIM16_DCR</displayName>
            <description>TIM16 DMA control register</description>
            <addressOffset>0x48</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...
Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>18 transfers.</description>
                    <value>0x11</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_DMAR</name>
            <displayName>TIM16_DMAR</displayName>
            <description>TIM16 DMA address for full transfer</description>
            <addressOffset>0x4c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address
(TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_AF1</name>
            <displayName>TIM16_AF1</displayName>
            <description>TIM16 alternate function register 1 </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BKINE</name>
                <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer’s BRK input. BKIN input is ‘ORed’ with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKINP</name>
                <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM16_TISEL</name>
            <displayName>TIM16_TISEL</displayName>
            <description>TIM16 input selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM16_CH1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LSE</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>MCO2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	  	  
    <peripheral>
        <name>TIM17</name>
        <description>General-purpose timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40014800</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM17</name>
          <description>TIM17 global interrupt</description>
          <value>22</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM17_CR1</name>
            <displayName>TIM17_CR1</displayName>
            <description>TIM17 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = tCK_INT</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 * tCK_INT</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 * tCK_INT</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved, do not program this value</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_CR2</name>
            <displayName>TIM17_CR2</displayName>
            <description>TIM17 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCPC</name>
                <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCxE, CCxNE and OCxM bits are not preloaded</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCUS</name>
                <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1</name>
                <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1=0 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1=1 (after a dead-time if OC1N is implemented) when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OIS1N</name>
                <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N=0 after a dead-time when MOE=0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N=1 after a dead-time when MOE=0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_DIER</name>
            <displayName>TIM17_DIER</displayName>
            <description>TIM17 DMA/interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMIE</name>
                <description>COM interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COM interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIE</name>
                <description>Break interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_SR</name>
            <displayName>TIM17_SR</displayName>
            <description>TIM17 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMIF</name>
                <description>COM interrupt flag
This flag is set by hardware on a COM event (once the capture/compare control bits –CCxE, CCxNE, OCxM– have been updated). It is cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No COM event occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COM interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIF</name>
                <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break event occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active level has been detected on the break input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_EGR</name>
            <displayName>TIM17_EGR</displayName>
            <description>TIM17 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMG</name>
                <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware.
Note: This bit acts only on channels that have a complementary output.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BG</name>
                <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_CCMR1_input</name>
            <displayName>TIM17_CCMR1_input</displayName>
            <description>TIM17 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM17_CCMR1_output</name>
            <displayName>TIM17_CCMR1_output</displayName>
            <description>TIM17 capture/compare mode register 1 [alternate]</description>
			<alternateRegister>TIM17_CCMR1_input</alternateRegister>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, IC1 is mapped on TI1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - OC1REF is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - OC1REF is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
          <register>
            <name>TIM17_CCER</name>
            <displayName>TIM17_CCER</displayName>
            <description>TIM17 capture/compare enable register</description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active (see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NE</name>
                <description>Capture/Compare 1 complementary output enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer
to the description of CC1P.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=”00” (the channel is configured in output).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1N active high</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1N active low</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_CNT</name>
            <displayName>TIM17_CNT</displayName>
            <description>TIM17 counter</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_PSC</name>
            <displayName>TIM17_PSC</displayName>
            <description>TIM17 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_ARR</name>
            <displayName>TIM17_ARR</displayName>
            <description>TIM17 auto-reload register</description>
            <addressOffset>0x2c</addressOffset>
            <size>16</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_RCR</name>
            <displayName>TIM17_RCR</displayName>
            <description>TIM17 repetition counter register</description>
            <addressOffset>0x30</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>REP</name>
                <description>Repetition counter value
These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event.
It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_CCR1</name>
            <displayName>TIM17_CCR1</displayName>
            <description>TIM17 capture/compare register 1</description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/Compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1 is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (IC1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_BDTR</name>
            <displayName>TIM17_BDTR</displayName>
            <description>TIM17 break and dead-time register</description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTG</name>
                <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5] = 0xx =&gt; DT = DTG[7:0] x tdtg with tdtg = tDTS
DTG[7:5] = 10x =&gt; DT = (64 + DTG[5:0]) x tdtg with tdtg = 2 x tDTS
DTG[7:5] = 110 =&gt; DT = (32 + DTG[4:0]) x tdtg with tdtg = 8 x tDTS
DTG[7:5] = 111 =&gt; DT = (32 + DTG[4:0]) x tdtg with tdtg = 16 x tDTS
Example if tDTS = 125 ns (8 MHz), dead-time possible values are:
0 to 15875 ns by 125 ns steps,
16 �s to 31750 ns by 250 ns steps,
32 �s to 63 �s by 1 �s steps,
64 �s to 126 �s by 2 �s steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LOCK OFF - No bit is write protected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSI</name>
                <description>Off-state selection for Idle mode
This bit is used when MOE=0 on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSSR</name>
                <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKE</name>
                <description>Break enable
1; Break inputs (BRK and CCS clock failure event) enabled
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break inputs (BRK and CCS clock failure event) disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKP</name>
                <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AOE</name>
                <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>MOE can be set only by software</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MOE can be set by software or automatically at the next update event (if the break input is not be active)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MOE</name>
                <description>Main output enable
This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details (</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKF</name>
                <description>Break filter
This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:
This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, BRK acts asynchronously</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=fCK_INT, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=fCK_INT, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=fCK_INT, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKDSRM</name>
                <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK is armed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK is disarmed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKBID</name>
                <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break input BRK in input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break input BRK in bidirectional mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_DCR</name>
            <displayName>TIM17_DCR</displayName>
            <description>TIM17 DMA control register</description>
            <addressOffset>0x48</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...
Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>18 transfers.</description>
                    <value>0x11</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_DMAR</name>
            <displayName>TIM17_DMAR</displayName>
            <description>TIM17 DMA address for full transfer</description>
            <addressOffset>0x4c</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address
(TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_AF1</name>
            <displayName>TIM17_AF1</displayName>
            <description>TIM17 alternate function register 1 </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BKINE</name>
                <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer’s BRK input. BKIN input is ‘ORed’ with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKINP</name>
                <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKIN input is active low</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKIN input is active high</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM17_TISEL</name>
            <displayName>TIM17_TISEL</displayName>
            <description>TIM17 input selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM17_CH1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE/32</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>MCO</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>MCO2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>USART1</name>
        <description>USART register block</description>
		<groupName>USART</groupName>
        <baseAddress>0x40013800</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>USART1</name>
          <description>USART1 global interrupt (combined with EXTI 25)</description>
          <value>27</value>
        </interrupt>		
        <registers>
          <register>
            <name>USART_CR1_enabled</name>
            <displayName>USART_CR1_enabled</displayName>
            <description>USART control register 1 [alternate] </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UE</name>
                <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1’. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever IDLE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNEIE</name>
                <description>RXFIFO not empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TC = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFNFIE</name>
                <description>TXFIFO not full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TXFNF =1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever PE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER8</name>
                <description>Oversampling mode
This bit can only be written when the USART is disabled (UE = 0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Oversampling by 16</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Oversampling by 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTOIE</name>
                <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBIE</name>
                <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE = 0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFEIE</name>
                <description>TXFIFO empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when TXFE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFFIE</name>
                <description>RXFIFO Full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when RXFF = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>USART_CR1_disabled</name>
            <displayName>USART_CR1_disabled</displayName>
            <description>USART control register 1 [alternate] </description>
			<alternateRegister>USART_CR1_enabled</alternateRegister>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
             <field>
                <name>UE</name>
                <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the CK pin is always available when CLKEN = 1, regardless of the UE bit value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1’. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever IDLE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNEIE</name>
                <description>Receive data register not empty
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TC = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXEIE</name>
                <description>Transmit data register empty
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TXE =1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever PE = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER8</name>
                <description>Oversampling mode
This bit can only be written when the USART is disabled (UE = 0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Oversampling by 16</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Oversampling by 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTOIE</name>
                <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBIE</name>
                <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE = 0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  
          <register>
            <name>USART_CR2</name>
            <displayName>USART_CR2</displayName>
            <description>USART control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SLVEN</name>
                <description>Synchronous Slave mode enable
When the SLVEN bit is set, the synchronous slave mode is enabled.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave mode enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS_NSS</name>
                <description>When the DIS_NSS bit is set, the NSS pin input is ignored.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI slave selection depends on NSS input pin.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI slave is always selected and NSS input pin is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDM7</name>
                <description>7-bit Address Detection/4-bit Address Detection
This bit is for selection between 4-bit address detection or 7-bit address detection.
This bit can only be written when the USART is disabled (UE = 0)
Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>4-bit address detection</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>7-bit address detection (in 8-bit data mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDL</name>
                <description>LIN break detection length
This bit is for selection between 11 bit or 10 bit break detection.
This bit can only be written when the USART is disabled (UE = 0).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>10-bit break detection</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>11-bit break detection</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDIE</name>
                <description>LIN break detection interrupt enable
Break interrupt mask (break detection using break delimiter).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated whenever LBDF = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBCL</name>
                <description>Last bit clock pulse
This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in synchronous mode.
The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.
This bit can only be written when the USART is disabled (UE = 0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The clock pulse of the last data bit is not output to the CK pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The clock pulse of the last data bit is output to the CK pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPHA</name>
                <description>Clock phase
This bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see  and )
This bit can only be written when the USART is disabled (UE = 0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The first clock transition is the first data capture edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The second clock transition is the first data capture edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPOL</name>
                <description>Clock polarity
This bit enables the user to select the polarity of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship
This bit can only be written when the USART is disabled (UE = 0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Steady low value on CK pin outside transmission window</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Steady high value on CK pin outside transmission window</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CLKEN</name>
                <description>Clock enable
This bit enables the user to enable the CK pin.
This bit can only be written when the USART is disabled (UE = 0).
Note: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to .
In Smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below must be respected:
UE = 0
SCEN = 1
GTPR configuration
CLKEN= 1
UE = 1</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CK pin disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CK pin enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>stop bits
These bits are used for programming the stop bits.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 stop bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>0.5 stop bit.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 stop bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>1.5 stop bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LINEN</name>
                <description>LIN mode enable
This bit is set and cleared by software.
The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LIN mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LIN mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWAP</name>
                <description>Swap TX/RX pins
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX/RX pins are used as defined in standard pinout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXINV</name>
                <description>RX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the RX line.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXINV</name>
                <description>TX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the TX line.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATAINV</name>
                <description>Binary data inversion
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSBFIRST</name>
                <description>Most significant bit first
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data is transmitted/received with data bit 0 first, following the start bit. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data is transmitted/received with the MSB (bit 7/8) first, following the start bit. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABREN</name>
                <description>Auto baud rate enable
This bit is set and cleared by software.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Auto baud rate detection is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Auto baud rate detection is enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABRMOD</name>
                <description>Auto baud rate mode
These bits are set and cleared by software.
This bitfield can only be written when ABREN = 0 or the USART is disabled (UE = 0).
Note: If DATAINV = 1 and/or MSBFIRST = 1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)
If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Measurement of the start bit is used to detect the baud rate. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>0x7F frame detection.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>0x55 frame detection</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTOEN</name>
                <description>Receiver timeout enable
This bit is set and cleared by software.
When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver timeout feature disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver timeout feature enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD</name>
                <description>Address of the USART node
These bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:
In Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.
In low-power mode: they are used for wake up from low-power mode on character match.
When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wakeup from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.
In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.
These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_CR3</name>
            <displayName>USART_CR3</displayName>
            <description>USART control register 3 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EIE</name>
                <description>Error interrupt enable
Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE = 1 or ORE = 1 or NE = 1 or UDR = 1 in the USART_ISR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IREN</name>
                <description>IrDA mode enable
This bit is set and cleared by software.
This bit can only be written when the USART is disabled (UE = 0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>IrDA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>IrDA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IRLP</name>
                <description>IrDA low-power
This bit is used for selecting between normal and low-power IrDA modes
This bit can only be written when the USART is disabled (UE = 0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low-power mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HDSEL</name>
                <description>Half-duplex selection
Selection of Single-wire Half-duplex mode
This bit can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Half duplex mode is not selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Half duplex mode is selected </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACK</name>
                <description>Smartcard NACK enable
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>NACK transmission in case of parity error is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>NACK transmission during parity error is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCEN</name>
                <description>Smartcard mode enable
This bit is used for enabling Smartcard mode.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Smartcard Mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Smartcard Mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAR</name>
                <description>DMA enable receiver
This bit is set/reset by software</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAT</name>
                <description>DMA enable transmitter
This bit is set/reset by software</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTSE</name>
                <description>RTS enable
This bit can only be written when the USART is disabled (UE = 0).
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSE</name>
                <description>CTS enable
This bit can only be written when the USART is disabled (UE = 0)
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIE</name>
                <description>CTS interrupt enable
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated whenever CTSIF = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONEBIT</name>
                <description>One sample bit method enable
This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.
This bit can only be written when the USART is disabled (UE = 0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Three sample bit method</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>One sample bit method</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRDIS</name>
                <description>Overrun Disable
This bit is used to disable the receive overrun detection.
the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.
This bit can only be written when the USART is disabled (UE = 0).
Note: This control bit enables checking the communication flow w/o reading the data</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Overrun Error Flag, ORE, is set when received data is not read before receiving new data. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun functionality is disabled. If new data is received while the RXNE flag is still set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDRE</name>
                <description>DMA Disable on Reception Error
This bit can only be written when the USART is disabled (UE=0).
Note: The reception errors are: parity error, framing error or noise error.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEM</name>
                <description>Driver enable mode
This bit enables the user to activate the external transceiver control, through the DE signal.
This bit can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE function is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE function is enabled. The DE signal is output on the RTS pin.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEP</name>
                <description>Driver enable polarity selection
This bit can only be written when the USART is disabled (UE = 0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE signal is active high. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE signal is active low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCARCNT</name>
                <description>Smartcard auto-retry count
This bitfield specifies the number of retries for transmission and reception in Smartcard mode.
In transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).
In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).
This bitfield must be programmed only when the USART is disabled (UE = 0).
When the USART is enabled (UE = 1), this bitfield may only be written to 0x0, in order to stop retransmission.
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>17</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>retransmission disabled - No automatic retransmission in transmit mode. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUS</name>
                <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the USART is disabled (UE = 0).
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WUF active on address match (as defined by ADD[7:0] and ADDM7)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>WUF active on start bit detection</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>WUF active on RXNE/RXFNE. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUFIE</name>
                <description>Wakeup from low-power mode interrupt enable
This bit is set and cleared by software.
Note: WUFIE must be set before entering in low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever WUF = 1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTIE</name>
                <description>TXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCBGTIE</name>
                <description>Transmission Complete before guard time, interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TCBGT=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTCFG</name>
                <description>Receive FIFO threshold configuration
Remaining combinations: Reserved</description>
                <bitOffset>25</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO reaches 1/8 of its depth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reaches 1/4 of its depth</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Receive FIFO reaches 1/2 of its depth</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Receive FIFO reaches 3/4 of its depth</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Receive FIFO reaches 7/8 of its depth</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Receive FIFO becomes full</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTIE</name>
                <description>RXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTCFG</name>
                <description>TXFIFO threshold configuration
Remaining combinations: Reserved</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO reaches 1/8 of its depth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reaches 1/4 of its depth</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TXFIFO reaches 1/2 of its depth</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>TXFIFO reaches 3/4 of its depth</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TXFIFO reaches 7/8 of its depth</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>TXFIFO becomes empty</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_BRR</name>
            <displayName>USART_BRR</displayName>
            <description>USART baud rate register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BRR</name>
                <description>USART baud rate
BRR[15:4]
BRR[15:4] = USARTDIV[15:4]
BRR[3:0]
When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].
When OVER8 = 1:
BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.
BRR[3] must be kept cleared.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_GTPR</name>
            <displayName>USART_GTPR</displayName>
            <description>USART guard time and prescaler register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
In IrDA low-power and normal IrDA mode:
PSC[7:0] = IrDA Normal and Low-Power baud rate
PSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits):
In Smartcard mode:
PSC[4:0] = Prescaler value
PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:
...
...
This bitfield can only be written when the USART is disabled (UE = 0).
Note: Bits [7:5] must be kept cleared if Smartcard mode is used.
This bitfield is reserved and forced by hardware to ‘0’ when the Smartcard and IrDA modes are not supported. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reserved - do not program this value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Divides the source clock by 1 (IrDA mode) / by 2 (Smarcard mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Divides the source clock by 2 (IrDA mode) / by 4 (Smartcard mode)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Divides the source clock by 3 (IrDA mode) / by 6 (Smartcard mode)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>Divides the source clock by 31 (IrDA mode) / by 62 (Smartcard mode)</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x20</name>
                    <description>Divides the source clock by 32 (IrDA mode)</description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xFF</name>
                    <description>Divides the source clock by 255 (IrDA mode)</description>
                    <value>0xFF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GT</name>
                <description>Guard time value
This bitfield is used to program the Guard time value in terms of number of baud clock periods.
This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.
This bitfield can only be written when the USART is disabled (UE = 0).
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RTOR</name>
            <displayName>USART_RTOR</displayName>
            <description>USART receiver timeout register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RTO</name>
                <description>Receiver timeout value
This bitfield gives the Receiver timeout value in terms of number of bits during which there is no activity on the RX line.
In standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.
In Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.
Note: This value must only be programmed once per received character.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BLEN</name>
                <description>Block Length
This bitfield gives the Block length in Smartcard T = 1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.
Examples:
BLEN = 0: 0 information characters + LEC
BLEN = 1: 0 information characters + CRC
BLEN = 255: 254 information characters + CRC (total 256 characters))
In Smartcard mode, the Block length counter is reset when TXE = 0 (TXFE = 0 in case FIFO mode is enabled).
This bitfield can be used also in other modes. In this case, the Block length counter is reset when RE = 0 (receiver disabled) and/or when the EOBCF bit is written to 1.
Note: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RQR</name>
            <displayName>USART_RQR</displayName>
            <description>USART request register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ABRRQ</name>
                <description>Auto baud rate request
Writing 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SBKRQ</name>
                <description>Send break request
Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.
Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MMRQ</name>
                <description>Mute mode request
Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RXFRQ</name>
                <description>Receive data flush request
Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.
This enables to discard the received data without reading them, and avoid an overrun condition.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXFRQ</name>
                <description>Transmit data flush request
When FIFO mode is disabled, writing ‘1’ to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.
When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.
Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_ISR_enabled</name>
            <displayName>USART_ISR_enabled</displayName>
            <description>USART interrupt and status register [alternate] </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x008000C0</resetValue>
            <resetMask>0xF0FFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
An interrupt is generated if PEIE = 1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No parity error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE = 1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Framing error is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Framing error or break character is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NE</name>
                <description>Noise detection flag
This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2012).
This error is associated with the character in the USART_RDR.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No noise is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
An interrupt is generated if RXFNEIE = 1 or EIE = 1 in the USART_CR1 register.
Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun error is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Idle line is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle line is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNE</name>
                <description>RXFIFO not empty
RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.
RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
An interrupt is generated if RXFNEIE = 1 in the USART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data is not received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Received data is ready to be read.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.
It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.
An interrupt is generated if TCIE = 1 in the USART_CR1 register.
TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission is not complete</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission is complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFNF</name>
                <description>TXFIFO not full
TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.
An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.
Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).
This bit is used during single buffer transmission.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmit FIFO is full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit FIFO is not full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDF</name>
                <description>LIN break detection flag
This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LIN Break not detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LIN break detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
An interrupt is generated if CTSIE = 1 in the USART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No change occurred on the nCTS status line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A change occurred on the nCTS status line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>nCTS line set</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>nCTS line reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTOF</name>
                <description>Receiver timeout
This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
An interrupt is generated if RTOIE = 1 in the USART_CR2 register.
In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timeout value not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout value reached without any data reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBF</name>
                <description>End of block flag
This bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
An interrupt is generated if the EOBIE = 1 in the USART_CR1 register.
It is cleared by software, writing 1 to the EOBCF in the USART_ICR register.
Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>End of Block not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of Block (number of characters) reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDR</name>
                <description>SPI slave underrun error flag
In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No underrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>underrun error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABRE</name>
                <description>Auto baud rate error
This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ABRF</name>
                <description>Auto baud rate flag
This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXFNE and FE are also set in this case)
It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART is idle (no reception)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reception on going</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
An interrupt is generated if CMIE = 1in the USART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Character match detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Character Match detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break character transmitted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break character requested by setting SBKRQ bit in USART_RQR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in active mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver in Mute mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
An interrupt is generated if WUFIE = 1 in the USART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
It can be used to verify that the USART is ready for reception before entering low-power mode.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFE</name>
                <description>TXFIFO empty
This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.
An interrupt is generated if the TXFEIE bit  = 1 (bit 30) in the USART_CR1 register.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO not empty.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO empty.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFF</name>
                <description>RXFIFO full
This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.
An interrupt is generated if the RXFFIE bit  = 1 in the USART_CR1 register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXFIFO not full.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXFIFO Full.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCBGT</name>
                <description>Transmission complete before guard time flag
This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE = 1 in the USART_CR3 register.
This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 1985.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFT</name>
                <description>RXFIFO threshold flag
This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit  = 1 (bit 27) in the USART_CR3 register.
Note: When the RXFTCFG threshold is configured to ‘101’, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFT</name>
                <description>TXFIFO threshold flag
This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit  = 1 (bit 31) in the USART_CR3 register.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		   <register>
            <name>USART_ISR_disabled</name>
            <displayName>USART_ISR_disabled</displayName>
            <description>USART interrupt and status register [alternate] </description>
			<alternateRegister>USART_ISR_enabled</alternateRegister>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x008000C0</resetValue>
            <resetMask>0xF0FFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
An interrupt is generated if PEIE = 1 in the USART_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No parity error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE = 1 in the USART_CR1 register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Framing error is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Framing error or break character is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NE</name>
                <description>Noise detection flag
This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2012).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No noise is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the USART_RDR register while RXNE = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
An interrupt is generated if RXNEIE = 1 or EIE  =  1 in the USART_CR1 register.
Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun error is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Idle line is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle line is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNE</name>
                <description>Read data register not empty
RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
An interrupt is generated if RXNEIE = 1 in the USART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data is not received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Received data is ready to be read.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.
It is set by hardware when the transmission of a frame containing data is complete and when TXE is set.
An interrupt is generated if TCIE = 1 in the USART_CR1 register.
TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission is not complete</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission is complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty
TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T = 0 mode, in case of transmission failure).
An interrupt is generated if the TXEIE bit  = 1 in the USART_CR1 register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data register full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Data register not full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDF</name>
                <description>LIN break detection flag
This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LIN Break not detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LIN break detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
An interrupt is generated if CTSIE = 1 in the USART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No change occurred on the nCTS status line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A change occurred on the nCTS status line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>nCTS line set</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>nCTS line reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTOF</name>
                <description>Receiver timeout
This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
An interrupt is generated if RTOIE = 1 in the USART_CR2 register.
In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timeout value not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout value reached without any data reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBF</name>
                <description>End of block flag
This bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
An interrupt is generated if the EOBIE = 1 in the USART_CR1 register.
It is cleared by software, writing 1 to the EOBCF in the USART_ICR register.
Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>End of Block not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of Block (number of characters) reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDR</name>
                <description>SPI slave underrun error flag
In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No underrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>underrun error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABRE</name>
                <description>Auto baud rate error
This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ABRF</name>
                <description>Auto baud rate flag
This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXNE and FE are also set in this case)
It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART is idle (no reception)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reception on going</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
An interrupt is generated if CMIE = 1in the USART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Character match detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Character Match detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Break character transmitted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break character requested by setting SBKRQ bit in USART_RQR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in active mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver in Mute mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
An interrupt is generated if WUFIE = 1 in the USART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
It can be used to verify that the USART is ready for reception before entering low-power mode.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>             
              <field>
                <name>TCBGT</name>
                <description>Transmission complete before guard time flag
This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE = 1 in the USART_CR3 register.
This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 1985.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>		  		  
          <register>
            <name>USART_ICR</name>
            <displayName>USART_ICR</displayName>
            <description>USART interrupt flag clear register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PECF</name>
                <description>Parity error clear flag
Writing 1 to this bit clears the PE flag in the USART_ISR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FECF</name>
                <description>Framing error clear flag
Writing 1 to this bit clears the FE flag in the USART_ISR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NECF</name>
                <description>Noise detected clear flag
Writing 1 to this bit clears the NE flag in the USART_ISR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ORECF</name>
                <description>Overrun error clear flag
Writing 1 to this bit clears the ORE flag in the USART_ISR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>IDLECF</name>
                <description>Idle line detected clear flag
Writing 1 to this bit clears the IDLE flag in the USART_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXFECF</name>
                <description>TXFIFO empty clear flag
Writing 1 to this bit clears the TXFE flag in the USART_ISR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TCCF</name>
                <description>Transmission complete clear flag
Writing 1 to this bit clears the TC flag in the USART_ISR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TCBGTCF</name>
                <description>Transmission complete before Guard time clear flag
Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LBDCF</name>
                <description>LIN break detection clear flag
Writing 1 to this bit clears the LBDF flag in the USART_ISR register.
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTSCF</name>
                <description>CTS clear flag
Writing 1 to this bit clears the CTSIF flag in the USART_ISR register.
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RTOCF</name>
                <description>Receiver timeout clear flag
Writing 1 to this bit clears the RTOF flag in the USART_ISR register.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EOBCF</name>
                <description>End of block clear flag
Writing 1 to this bit clears the EOBF flag in the USART_ISR register.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UDRCF</name>
                <description>SPI slave underrun clear flag
Writing 1 to this bit clears the UDRF flag in the USART_ISR register.
Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMCF</name>
                <description>Character match clear flag
Writing 1 to this bit clears the CMF flag in the USART_ISR register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WUCF</name>
                <description>Wakeup from low-power mode clear flag
Writing 1 to this bit clears the WUF flag in the USART_ISR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RDR</name>
            <displayName>USART_RDR</displayName>
            <description>USART receive data register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDR</name>
                <description>Receive data value
Contains the received data character.
The RDR register provides the parallel interface between the input shift register and the internal bus (see ).
When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_TDR</name>
            <displayName>USART_TDR</displayName>
            <description>USART transmit data register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDR</name>
                <description>Transmit data value
Contains the data character to be transmitted.
The USART_TDR register provides the parallel interface between the internal bus and the output shift register (see ).
When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.
Note: This register must be written only when TXE/TXFNF = 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_PRESC</name>
            <displayName>USART_PRESC</displayName>
            <description>USART prescaler register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Clock prescaler
The USART input clock can be divided by a prescaler factor:
Remaining combinations: Reserved
Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>input clock not divided</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>input clock divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>input clock divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>input clock divided by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>input clock divided by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>input clock divided by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>input clock divided by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>input clock divided by 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>input clock divided by 32</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>input clock divided by 64</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>input clock divided by 128</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>input clock divided by 256</description>
                    <value>0xB</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	  
	<peripheral derivedFrom="USART1">
        <name>USART2</name>
        <baseAddress>0x40004400</baseAddress>
        <interrupt>
          <name>USART2</name>
          <description>USART2 global interrupt (combined with EXTI 25)</description>
          <value>28</value>
        </interrupt>	  
    </peripheral>
	<peripheral>
        <name>WWDG</name>
        <description>WWDG register block</description>
		<groupName>WWDG</groupName>
        <baseAddress>0x40002C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>WWDG</name>
          <description>Window watchdog interrupt</description>
          <value>0</value>
        </interrupt>
        <registers>
          <register>
            <name>WWDG_CR</name>
            <displayName>WWDG_CR</displayName>
            <description>WWDG control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>T</name>
                <description>7-bit counter (MSB to LSB)
These bits contain the value of the watchdog counter, decremented every
(4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGA</name>
                <description>Activation bit
This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Watchdog disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Watchdog enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_CFR</name>
            <displayName>WWDG_CFR</displayName>
            <description>WWDG configuration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>W</name>
                <description>7-bit window value
These bits contain the window value to be compared with the down-counter.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWI</name>
                <description>Early wakeup interrupt
When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGTB</name>
                <description>Timer base
The timebase of the prescaler can be modified as follows:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CK counter clock (PCLK div 4096) div 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CK counter clock (PCLK div 4096) div 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CK counter clock (PCLK div 4096) div 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CK counter clock (PCLK div 4096) div 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CK counter clock (PCLK div 4096) div 16</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>CK counter clock (PCLK div 4096) div 32</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>CK counter clock (PCLK div 4096) div 64</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>CK counter clock (PCLK div 4096) div 128</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_SR</name>
            <displayName>WWDG_SR</displayName>
            <description>WWDG status register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWIF</name>
                <description>Early wakeup interrupt flag
This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing ‘0’. Writing ‘1’ has no effect. This bit is also set if the interrupt is not enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>        			
  </peripherals>
</device>
